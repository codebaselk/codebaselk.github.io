var Cp = Object.defineProperty, Tp = Object.defineProperties; var Mp = Object.getOwnPropertyDescriptors; var jc = Object.getOwnPropertySymbols; var _p = Object.prototype.hasOwnProperty, Np = Object.prototype.propertyIsEnumerable; var Hc = (e, t, n) => t in e ? Cp(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n }) : e[t] = n, y = (e, t) => { for (var n in t ||= {}) _p.call(t, n) && Hc(e, n, t[n]); if (jc) for (var n of jc(t)) Np.call(t, n) && Hc(e, n, t[n]); return e }, V = (e, t) => Tp(e, Mp(t)); var _i; function jr() { return _i } function Ae(e) { let t = _i; return _i = e, t } var Vc = Symbol("NotFound"); function Ft(e) { return e === Vc || e?.name === "\u0275NotFound" } var re = null, Hr = !1, Ni = 1, xp = null, se = Symbol("SIGNAL"); function x(e) { let t = re; return re = e, t } function Ur() { return re } var bn = { version: 0, lastCleanEpoch: 0, dirty: !1, producers: void 0, producersTail: void 0, consumers: void 0, consumersTail: void 0, recomputing: !1, consumerAllowSignalWrites: !1, consumerIsAlwaysLive: !1, kind: "unknown", producerMustRecompute: () => !1, producerRecomputeValue: () => { }, consumerMarkedDirty: () => { }, consumerOnSignalRead: () => { } }; function Cn(e) { if (Hr) throw new Error(""); if (re === null) return; re.consumerOnSignalRead(e); let t = re.producersTail; if (t !== void 0 && t.producer === e) return; let n, r = re.recomputing; if (r && (n = t !== void 0 ? t.nextProducer : re.producers, n !== void 0 && n.producer === e)) { re.producersTail = n, n.lastReadVersion = e.version; return } let o = e.consumersTail; if (o !== void 0 && o.consumer === re && (!r || Ap(o, re))) return; let i = jt(re), s = { producer: e, consumer: re, nextProducer: n, prevConsumer: o, lastReadVersion: e.version, nextConsumer: void 0 }; re.producersTail = s, t !== void 0 ? t.nextProducer = s : re.producers = s, i && zc(e, s) } function Uc() { Ni++ } function xi(e) { if (!(jt(e) && !e.dirty) && !(!e.dirty && e.lastCleanEpoch === Ni)) { if (!e.producerMustRecompute(e) && !Mn(e)) { Vr(e); return } e.producerRecomputeValue(e), Vr(e) } } function Ri(e) { if (e.consumers === void 0) return; let t = Hr; Hr = !0; try { for (let n = e.consumers; n !== void 0; n = n.nextConsumer) { let r = n.consumer; r.dirty || Rp(r) } } finally { Hr = t } } function Ai() { return re?.consumerAllowSignalWrites !== !1 } function Rp(e) { e.dirty = !0, Ri(e), e.consumerMarkedDirty?.(e) } function Vr(e) { e.dirty = !1, e.lastCleanEpoch = Ni } function Tn(e) { return e && $c(e), x(e) } function $c(e) { e.producersTail = void 0, e.recomputing = !0 } function $r(e, t) { x(t), e && Bc(e) } function Bc(e) { e.recomputing = !1; let t = e.producersTail, n = t !== void 0 ? t.nextProducer : e.producers; if (n !== void 0) { if (jt(e)) do n = Oi(n); while (n !== void 0); t !== void 0 ? t.nextProducer = void 0 : e.producers = void 0 } } function Mn(e) { for (let t = e.producers; t !== void 0; t = t.nextProducer) { let n = t.producer, r = t.lastReadVersion; if (r !== n.version || (xi(n), r !== n.version)) return !0 } return !1 } function _n(e) { if (jt(e)) { let t = e.producers; for (; t !== void 0;)t = Oi(t) } e.producers = void 0, e.producersTail = void 0, e.consumers = void 0, e.consumersTail = void 0 } function zc(e, t) { let n = e.consumersTail, r = jt(e); if (n !== void 0 ? (t.nextConsumer = n.nextConsumer, n.nextConsumer = t) : (t.nextConsumer = void 0, e.consumers = t), t.prevConsumer = n, e.consumersTail = t, !r) for (let o = e.producers; o !== void 0; o = o.nextProducer)zc(o.producer, o) } function Oi(e) { let t = e.producer, n = e.nextProducer, r = e.nextConsumer, o = e.prevConsumer; if (e.nextConsumer = void 0, e.prevConsumer = void 0, r !== void 0 ? r.prevConsumer = o : t.consumersTail = o, o !== void 0) o.nextConsumer = r; else if (t.consumers = r, !jt(t)) { let i = t.producers; for (; i !== void 0;)i = Oi(i) } return n } function jt(e) { return e.consumerIsAlwaysLive || e.consumers !== void 0 } function ki(e) { xp?.(e) } function Ap(e, t) { let n = t.producersTail; if (n !== void 0) { let r = t.producers; do { if (r === e) return !0; if (r === n) break; r = r.nextProducer } while (r !== void 0) } return !1 } function Pi(e, t) { return Object.is(e, t) } function Op() { throw new Error } var qc = Op; function Gc(e) { qc(e) } function Li(e) { qc = e } var kp = null; function Fi(e, t) { let n = Object.create(Br); n.value = e, t !== void 0 && (n.equal = t); let r = () => Wc(n); return r[se] = n, ki(n), [r, s => Ht(n, s), s => ji(n, s)] } function Wc(e) { return Cn(e), e.value } function Ht(e, t) { Ai() || Gc(e), e.equal(e.value, t) || (e.value = t, Pp(e)) } function ji(e, t) { Ai() || Gc(e), Ht(e, t(e.value)) } var Br = V(y({}, bn), { equal: Pi, value: void 0, kind: "signal" }); function Pp(e) { e.version++, Uc(), Ri(e), kp?.(e) } function b(e) { return typeof e == "function" } function Vt(e) { let n = e(r => { Error.call(r), r.stack = new Error().stack }); return n.prototype = Object.create(Error.prototype), n.prototype.constructor = n, n } var zr = Vt(e => function (n) {
  e(this), this.message = n ? `${n.length} errors occurred during unsubscription:
${n.map((r, o) => `${o + 1}) ${r.toString()}`).join(`
  `)}` : "", this.name = "UnsubscriptionError", this.errors = n
}); function Nn(e, t) { if (e) { let n = e.indexOf(t); 0 <= n && e.splice(n, 1) } } var B = class e { constructor(t) { this.initialTeardown = t, this.closed = !1, this._parentage = null, this._finalizers = null } unsubscribe() { let t; if (!this.closed) { this.closed = !0; let { _parentage: n } = this; if (n) if (this._parentage = null, Array.isArray(n)) for (let i of n) i.remove(this); else n.remove(this); let { initialTeardown: r } = this; if (b(r)) try { r() } catch (i) { t = i instanceof zr ? i.errors : [i] } let { _finalizers: o } = this; if (o) { this._finalizers = null; for (let i of o) try { Qc(i) } catch (s) { t = t ?? [], s instanceof zr ? t = [...t, ...s.errors] : t.push(s) } } if (t) throw new zr(t) } } add(t) { var n; if (t && t !== this) if (this.closed) Qc(t); else { if (t instanceof e) { if (t.closed || t._hasParent(this)) return; t._addParent(this) } (this._finalizers = (n = this._finalizers) !== null && n !== void 0 ? n : []).push(t) } } _hasParent(t) { let { _parentage: n } = this; return n === t || Array.isArray(n) && n.includes(t) } _addParent(t) { let { _parentage: n } = this; this._parentage = Array.isArray(n) ? (n.push(t), n) : n ? [n, t] : t } _removeParent(t) { let { _parentage: n } = this; n === t ? this._parentage = null : Array.isArray(n) && Nn(n, t) } remove(t) { let { _finalizers: n } = this; n && Nn(n, t), t instanceof e && t._removeParent(this) } }; B.EMPTY = (() => { let e = new B; return e.closed = !0, e })(); var Hi = B.EMPTY; function qr(e) { return e instanceof B || e && "closed" in e && b(e.remove) && b(e.add) && b(e.unsubscribe) } function Qc(e) { b(e) ? e() : e.unsubscribe() } var Te = { onUnhandledError: null, onStoppedNotification: null, Promise: void 0, useDeprecatedSynchronousErrorHandling: !1, useDeprecatedNextContext: !1 }; var Ut = { setTimeout(e, t, ...n) { let { delegate: r } = Ut; return r?.setTimeout ? r.setTimeout(e, t, ...n) : setTimeout(e, t, ...n) }, clearTimeout(e) { let { delegate: t } = Ut; return (t?.clearTimeout || clearTimeout)(e) }, delegate: void 0 }; function Gr(e) { Ut.setTimeout(() => { let { onUnhandledError: t } = Te; if (t) t(e); else throw e }) } function xn() { } var Zc = Vi("C", void 0, void 0); function Yc(e) { return Vi("E", void 0, e) } function Kc(e) { return Vi("N", e, void 0) } function Vi(e, t, n) { return { kind: e, value: t, error: n } } var pt = null; function $t(e) { if (Te.useDeprecatedSynchronousErrorHandling) { let t = !pt; if (t && (pt = { errorThrown: !1, error: null }), e(), t) { let { errorThrown: n, error: r } = pt; if (pt = null, n) throw r } } else e() } function Jc(e) { Te.useDeprecatedSynchronousErrorHandling && pt && (pt.errorThrown = !0, pt.error = e) } var ht = class extends B { constructor(t) { super(), this.isStopped = !1, t ? (this.destination = t, qr(t) && t.add(this)) : this.destination = jp } static create(t, n, r) { return new Bt(t, n, r) } next(t) { this.isStopped ? $i(Kc(t), this) : this._next(t) } error(t) { this.isStopped ? $i(Yc(t), this) : (this.isStopped = !0, this._error(t)) } complete() { this.isStopped ? $i(Zc, this) : (this.isStopped = !0, this._complete()) } unsubscribe() { this.closed || (this.isStopped = !0, super.unsubscribe(), this.destination = null) } _next(t) { this.destination.next(t) } _error(t) { try { this.destination.error(t) } finally { this.unsubscribe() } } _complete() { try { this.destination.complete() } finally { this.unsubscribe() } } }, Lp = Function.prototype.bind; function Ui(e, t) { return Lp.call(e, t) } var Bi = class { constructor(t) { this.partialObserver = t } next(t) { let { partialObserver: n } = this; if (n.next) try { n.next(t) } catch (r) { Wr(r) } } error(t) { let { partialObserver: n } = this; if (n.error) try { n.error(t) } catch (r) { Wr(r) } else Wr(t) } complete() { let { partialObserver: t } = this; if (t.complete) try { t.complete() } catch (n) { Wr(n) } } }, Bt = class extends ht { constructor(t, n, r) { super(); let o; if (b(t) || !t) o = { next: t ?? void 0, error: n ?? void 0, complete: r ?? void 0 }; else { let i; this && Te.useDeprecatedNextContext ? (i = Object.create(t), i.unsubscribe = () => this.unsubscribe(), o = { next: t.next && Ui(t.next, i), error: t.error && Ui(t.error, i), complete: t.complete && Ui(t.complete, i) }) : o = t } this.destination = new Bi(o) } }; function Wr(e) { Te.useDeprecatedSynchronousErrorHandling ? Jc(e) : Gr(e) } function Fp(e) { throw e } function $i(e, t) { let { onStoppedNotification: n } = Te; n && Ut.setTimeout(() => n(e, t)) } var jp = { closed: !0, next: xn, error: Fp, complete: xn }; var zt = typeof Symbol == "function" && Symbol.observable || "@@observable"; function pe(e) { return e } function zi(...e) { return qi(e) } function qi(e) { return e.length === 0 ? pe : e.length === 1 ? e[0] : function (n) { return e.reduce((r, o) => o(r), n) } } var k = (() => { class e { constructor(n) { n && (this._subscribe = n) } lift(n) { let r = new e; return r.source = this, r.operator = n, r } subscribe(n, r, o) { let i = Vp(n) ? n : new Bt(n, r, o); return $t(() => { let { operator: s, source: a } = this; i.add(s ? s.call(i, a) : a ? this._subscribe(i) : this._trySubscribe(i)) }), i } _trySubscribe(n) { try { return this._subscribe(n) } catch (r) { n.error(r) } } forEach(n, r) { return r = Xc(r), new r((o, i) => { let s = new Bt({ next: a => { try { n(a) } catch (c) { i(c), s.unsubscribe() } }, error: i, complete: o }); this.subscribe(s) }) } _subscribe(n) { var r; return (r = this.source) === null || r === void 0 ? void 0 : r.subscribe(n) } [zt]() { return this } pipe(...n) { return qi(n)(this) } toPromise(n) { return n = Xc(n), new n((r, o) => { let i; this.subscribe(s => i = s, s => o(s), () => r(i)) }) } } return e.create = t => new e(t), e })(); function Xc(e) { var t; return (t = e ?? Te.Promise) !== null && t !== void 0 ? t : Promise } function Hp(e) { return e && b(e.next) && b(e.error) && b(e.complete) } function Vp(e) { return e && e instanceof ht || Hp(e) && qr(e) } function Gi(e) { return b(e?.lift) } function R(e) { return t => { if (Gi(t)) return t.lift(function (n) { try { return e(n, this) } catch (r) { this.error(r) } }); throw new TypeError("Unable to lift unknown Observable type") } } function A(e, t, n, r, o) { return new Wi(e, t, n, r, o) } var Wi = class extends ht { constructor(t, n, r, o, i, s) { super(t), this.onFinalize = i, this.shouldUnsubscribe = s, this._next = n ? function (a) { try { n(a) } catch (c) { t.error(c) } } : super._next, this._error = o ? function (a) { try { o(a) } catch (c) { t.error(c) } finally { this.unsubscribe() } } : super._error, this._complete = r ? function () { try { r() } catch (a) { t.error(a) } finally { this.unsubscribe() } } : super._complete } unsubscribe() { var t; if (!this.shouldUnsubscribe || this.shouldUnsubscribe()) { let { closed: n } = this; super.unsubscribe(), !n && ((t = this.onFinalize) === null || t === void 0 || t.call(this)) } } }; function qt() { return R((e, t) => { let n = null; e._refCount++; let r = A(t, void 0, void 0, void 0, () => { if (!e || e._refCount <= 0 || 0 < --e._refCount) { n = null; return } let o = e._connection, i = n; n = null, o && (!i || o === i) && o.unsubscribe(), t.unsubscribe() }); e.subscribe(r), r.closed || (n = e.connect()) }) } var Gt = class extends k { constructor(t, n) { super(), this.source = t, this.subjectFactory = n, this._subject = null, this._refCount = 0, this._connection = null, Gi(t) && (this.lift = t.lift) } _subscribe(t) { return this.getSubject().subscribe(t) } getSubject() { let t = this._subject; return (!t || t.isStopped) && (this._subject = this.subjectFactory()), this._subject } _teardown() { this._refCount = 0; let { _connection: t } = this; this._subject = this._connection = null, t?.unsubscribe() } connect() { let t = this._connection; if (!t) { t = this._connection = new B; let n = this.getSubject(); t.add(this.source.subscribe(A(n, void 0, () => { this._teardown(), n.complete() }, r => { this._teardown(), n.error(r) }, () => this._teardown()))), t.closed && (this._connection = null, t = B.EMPTY) } return t } refCount() { return qt()(this) } }; var el = Vt(e => function () { e(this), this.name = "ObjectUnsubscribedError", this.message = "object unsubscribed" }); var Y = (() => { class e extends k { constructor() { super(), this.closed = !1, this.currentObservers = null, this.observers = [], this.isStopped = !1, this.hasError = !1, this.thrownError = null } lift(n) { let r = new Qr(this, this); return r.operator = n, r } _throwIfClosed() { if (this.closed) throw new el } next(n) { $t(() => { if (this._throwIfClosed(), !this.isStopped) { this.currentObservers || (this.currentObservers = Array.from(this.observers)); for (let r of this.currentObservers) r.next(n) } }) } error(n) { $t(() => { if (this._throwIfClosed(), !this.isStopped) { this.hasError = this.isStopped = !0, this.thrownError = n; let { observers: r } = this; for (; r.length;)r.shift().error(n) } }) } complete() { $t(() => { if (this._throwIfClosed(), !this.isStopped) { this.isStopped = !0; let { observers: n } = this; for (; n.length;)n.shift().complete() } }) } unsubscribe() { this.isStopped = this.closed = !0, this.observers = this.currentObservers = null } get observed() { var n; return ((n = this.observers) === null || n === void 0 ? void 0 : n.length) > 0 } _trySubscribe(n) { return this._throwIfClosed(), super._trySubscribe(n) } _subscribe(n) { return this._throwIfClosed(), this._checkFinalizedStatuses(n), this._innerSubscribe(n) } _innerSubscribe(n) { let { hasError: r, isStopped: o, observers: i } = this; return r || o ? Hi : (this.currentObservers = null, i.push(n), new B(() => { this.currentObservers = null, Nn(i, n) })) } _checkFinalizedStatuses(n) { let { hasError: r, thrownError: o, isStopped: i } = this; r ? n.error(o) : i && n.complete() } asObservable() { let n = new k; return n.source = this, n } } return e.create = (t, n) => new Qr(t, n), e })(), Qr = class extends Y { constructor(t, n) { super(), this.destination = t, this.source = n } next(t) { var n, r; (r = (n = this.destination) === null || n === void 0 ? void 0 : n.next) === null || r === void 0 || r.call(n, t) } error(t) { var n, r; (r = (n = this.destination) === null || n === void 0 ? void 0 : n.error) === null || r === void 0 || r.call(n, t) } complete() { var t, n; (n = (t = this.destination) === null || t === void 0 ? void 0 : t.complete) === null || n === void 0 || n.call(t) } _subscribe(t) { var n, r; return (r = (n = this.source) === null || n === void 0 ? void 0 : n.subscribe(t)) !== null && r !== void 0 ? r : Hi } }; var K = class extends Y { constructor(t) { super(), this._value = t } get value() { return this.getValue() } _subscribe(t) { let n = super._subscribe(t); return !n.closed && t.next(this._value), n } getValue() { let { hasError: t, thrownError: n, _value: r } = this; if (t) throw n; return this._throwIfClosed(), r } next(t) { super.next(this._value = t) } }; var ae = new k(e => e.complete()); function tl(e) { return e && b(e.schedule) } function nl(e) { return e[e.length - 1] } function rl(e) { return b(nl(e)) ? e.pop() : void 0 } function Xe(e) { return tl(nl(e)) ? e.pop() : void 0 } function il(e, t, n, r) { function o(i) { return i instanceof n ? i : new n(function (s) { s(i) }) } return new (n || (n = Promise))(function (i, s) { function a(p) { try { l(r.next(p)) } catch (h) { s(h) } } function c(p) { try { l(r.throw(p)) } catch (h) { s(h) } } function l(p) { p.done ? i(p.value) : o(p.value).then(a, c) } l((r = r.apply(e, t || [])).next()) }) } function ol(e) { var t = typeof Symbol == "function" && Symbol.iterator, n = t && e[t], r = 0; if (n) return n.call(e); if (e && typeof e.length == "number") return { next: function () { return e && r >= e.length && (e = void 0), { value: e && e[r++], done: !e } } }; throw new TypeError(t ? "Object is not iterable." : "Symbol.iterator is not defined.") } function gt(e) { return this instanceof gt ? (this.v = e, this) : new gt(e) } function sl(e, t, n) { if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined."); var r = n.apply(e, t || []), o, i = []; return o = Object.create((typeof AsyncIterator == "function" ? AsyncIterator : Object).prototype), a("next"), a("throw"), a("return", s), o[Symbol.asyncIterator] = function () { return this }, o; function s(g) { return function (w) { return Promise.resolve(w).then(g, h) } } function a(g, w) { r[g] && (o[g] = function (N) { return new Promise(function (H, j) { i.push([g, N, H, j]) > 1 || c(g, N) }) }, w && (o[g] = w(o[g]))) } function c(g, w) { try { l(r[g](w)) } catch (N) { v(i[0][3], N) } } function l(g) { g.value instanceof gt ? Promise.resolve(g.value.v).then(p, h) : v(i[0][2], g) } function p(g) { c("next", g) } function h(g) { c("throw", g) } function v(g, w) { g(w), i.shift(), i.length && c(i[0][0], i[0][1]) } } function al(e) { if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined."); var t = e[Symbol.asyncIterator], n; return t ? t.call(e) : (e = typeof ol == "function" ? ol(e) : e[Symbol.iterator](), n = {}, r("next"), r("throw"), r("return"), n[Symbol.asyncIterator] = function () { return this }, n); function r(i) { n[i] = e[i] && function (s) { return new Promise(function (a, c) { s = e[i](s), o(a, c, s.done, s.value) }) } } function o(i, s, a, c) { Promise.resolve(c).then(function (l) { i({ value: l, done: a }) }, s) } } var Zr = e => e && typeof e.length == "number" && typeof e != "function"; function Yr(e) { return b(e?.then) } function Kr(e) { return b(e[zt]) } function Jr(e) { return Symbol.asyncIterator && b(e?.[Symbol.asyncIterator]) } function Xr(e) { return new TypeError(`You provided ${e !== null && typeof e == "object" ? "an invalid object" : `'${e}'`} where a stream was expected. You can provide an Observable, Promise, ReadableStream, Array, AsyncIterable, or Iterable.`) } function Up() { return typeof Symbol != "function" || !Symbol.iterator ? "@@iterator" : Symbol.iterator } var eo = Up(); function to(e) { return b(e?.[eo]) } function no(e) { return sl(this, arguments, function* () { let n = e.getReader(); try { for (; ;) { let { value: r, done: o } = yield gt(n.read()); if (o) return yield gt(void 0); yield yield gt(r) } } finally { n.releaseLock() } }) } function ro(e) { return b(e?.getReader) } function W(e) { if (e instanceof k) return e; if (e != null) { if (Kr(e)) return $p(e); if (Zr(e)) return Bp(e); if (Yr(e)) return zp(e); if (Jr(e)) return cl(e); if (to(e)) return qp(e); if (ro(e)) return Gp(e) } throw Xr(e) } function $p(e) { return new k(t => { let n = e[zt](); if (b(n.subscribe)) return n.subscribe(t); throw new TypeError("Provided object does not correctly implement Symbol.observable") }) } function Bp(e) { return new k(t => { for (let n = 0; n < e.length && !t.closed; n++)t.next(e[n]); t.complete() }) } function zp(e) { return new k(t => { e.then(n => { t.closed || (t.next(n), t.complete()) }, n => t.error(n)).then(null, Gr) }) } function qp(e) { return new k(t => { for (let n of e) if (t.next(n), t.closed) return; t.complete() }) } function cl(e) { return new k(t => { Wp(e, t).catch(n => t.error(n)) }) } function Gp(e) { return cl(no(e)) } function Wp(e, t) { var n, r, o, i; return il(this, void 0, void 0, function* () { try { for (n = al(e); r = yield n.next(), !r.done;) { let s = r.value; if (t.next(s), t.closed) return } } catch (s) { o = { error: s } } finally { try { r && !r.done && (i = n.return) && (yield i.call(n)) } finally { if (o) throw o.error } } t.complete() }) } function ce(e, t, n, r = 0, o = !1) { let i = t.schedule(function () { n(), o ? e.add(this.schedule(null, r)) : this.unsubscribe() }, r); if (e.add(i), !o) return i } function oo(e, t = 0) { return R((n, r) => { n.subscribe(A(r, o => ce(r, e, () => r.next(o), t), () => ce(r, e, () => r.complete(), t), o => ce(r, e, () => r.error(o), t))) }) } function io(e, t = 0) { return R((n, r) => { r.add(e.schedule(() => n.subscribe(r), t)) }) } function ll(e, t) { return W(e).pipe(io(t), oo(t)) } function ul(e, t) { return W(e).pipe(io(t), oo(t)) } function dl(e, t) { return new k(n => { let r = 0; return t.schedule(function () { r === e.length ? n.complete() : (n.next(e[r++]), n.closed || this.schedule()) }) }) } function fl(e, t) { return new k(n => { let r; return ce(n, t, () => { r = e[eo](), ce(n, t, () => { let o, i; try { ({ value: o, done: i } = r.next()) } catch (s) { n.error(s); return } i ? n.complete() : n.next(o) }, 0, !0) }), () => b(r?.return) && r.return() }) } function so(e, t) { if (!e) throw new Error("Iterable cannot be null"); return new k(n => { ce(n, t, () => { let r = e[Symbol.asyncIterator](); ce(n, t, () => { r.next().then(o => { o.done ? n.complete() : n.next(o.value) }) }, 0, !0) }) }) } function pl(e, t) { return so(no(e), t) } function hl(e, t) { if (e != null) { if (Kr(e)) return ll(e, t); if (Zr(e)) return dl(e, t); if (Yr(e)) return ul(e, t); if (Jr(e)) return so(e, t); if (to(e)) return fl(e, t); if (ro(e)) return pl(e, t) } throw Xr(e) } function z(e, t) { return t ? hl(e, t) : W(e) } function D(...e) { let t = Xe(e); return z(e, t) } function Wt(e, t) { let n = b(e) ? e : () => e, r = o => o.error(n()); return new k(t ? o => t.schedule(r, 0, o) : r) } function Qi(e) { return !!e && (e instanceof k || b(e.lift) && b(e.subscribe)) } var He = Vt(e => function () { e(this), this.name = "EmptyError", this.message = "no elements in sequence" }); function O(e, t) { return R((n, r) => { let o = 0; n.subscribe(A(r, i => { r.next(e.call(t, i, o++)) })) }) } var { isArray: Qp } = Array; function Zp(e, t) { return Qp(t) ? e(...t) : e(t) } function gl(e) { return O(t => Zp(e, t)) } var { isArray: Yp } = Array, { getPrototypeOf: Kp, prototype: Jp, keys: Xp } = Object; function ml(e) { if (e.length === 1) { let t = e[0]; if (Yp(t)) return { args: t, keys: null }; if (eh(t)) { let n = Xp(t); return { args: n.map(r => t[r]), keys: n } } } return { args: e, keys: null } } function eh(e) { return e && typeof e == "object" && Kp(e) === Jp } function vl(e, t) { return e.reduce((n, r, o) => (n[r] = t[o], n), {}) } function ao(...e) { let t = Xe(e), n = rl(e), { args: r, keys: o } = ml(e); if (r.length === 0) return z([], t); let i = new k(th(r, t, o ? s => vl(o, s) : pe)); return n ? i.pipe(gl(n)) : i } function th(e, t, n = pe) { return r => { yl(t, () => { let { length: o } = e, i = new Array(o), s = o, a = o; for (let c = 0; c < o; c++)yl(t, () => { let l = z(e[c], t), p = !1; l.subscribe(A(r, h => { i[c] = h, p || (p = !0, a--), a || r.next(n(i.slice())) }, () => { --s || r.complete() })) }, r) }, r) } } function yl(e, t, n) { e ? ce(n, e, t) : t() } function El(e, t, n, r, o, i, s, a) { let c = [], l = 0, p = 0, h = !1, v = () => { h && !c.length && !l && t.complete() }, g = N => l < r ? w(N) : c.push(N), w = N => { i && t.next(N), l++; let H = !1; W(n(N, p++)).subscribe(A(t, j => { o?.(j), i ? g(j) : t.next(j) }, () => { H = !0 }, void 0, () => { if (H) try { for (l--; c.length && l < r;) { let j = c.shift(); s ? ce(t, s, () => w(j)) : w(j) } v() } catch (j) { t.error(j) } })) }; return e.subscribe(A(t, g, () => { h = !0, v() })), () => { a?.() } } function q(e, t, n = 1 / 0) { return b(t) ? q((r, o) => O((i, s) => t(r, i, o, s))(W(e(r, o))), n) : (typeof t == "number" && (n = t), R((r, o) => El(r, o, e, n))) } function Il(e = 1 / 0) { return q(pe, e) } function Sl() { return Il(1) } function Qt(...e) { return Sl()(z(e, Xe(e))) } function Rn(e) { return new k(t => { W(e()).subscribe(t) }) } function Ie(e, t) { return R((n, r) => { let o = 0; n.subscribe(A(r, i => e.call(t, i, o++) && r.next(i))) }) } function et(e) { return R((t, n) => { let r = null, o = !1, i; r = t.subscribe(A(n, void 0, void 0, s => { i = W(e(s, et(e)(t))), r ? (r.unsubscribe(), r = null, i.subscribe(n)) : o = !0 })), o && (r.unsubscribe(), r = null, i.subscribe(n)) }) } function wl(e, t, n, r, o) { return (i, s) => { let a = n, c = t, l = 0; i.subscribe(A(s, p => { let h = l++; c = a ? e(c, p, h) : (a = !0, p), r && s.next(c) }, o && (() => { a && s.next(c), s.complete() }))) } } function Zt(e, t) { return b(t) ? q(e, t, 1) : q(e, 1) } function tt(e) { return R((t, n) => { let r = !1; t.subscribe(A(n, o => { r = !0, n.next(o) }, () => { r || n.next(e), n.complete() })) }) } function Ve(e) { return e <= 0 ? () => ae : R((t, n) => { let r = 0; t.subscribe(A(n, o => { ++r <= e && (n.next(o), e <= r && n.complete()) })) }) } function co(e = nh) { return R((t, n) => { let r = !1; t.subscribe(A(n, o => { r = !0, n.next(o) }, () => r ? n.complete() : n.error(e()))) }) } function nh() { return new He } function An(e) { return R((t, n) => { try { t.subscribe(n) } finally { n.add(e) } }) } function Ue(e, t) { let n = arguments.length >= 2; return r => r.pipe(e ? Ie((o, i) => e(o, i, r)) : pe, Ve(1), n ? tt(t) : co(() => new He)) } function Yt(e) { return e <= 0 ? () => ae : R((t, n) => { let r = []; t.subscribe(A(n, o => { r.push(o), e < r.length && r.shift() }, () => { for (let o of r) n.next(o); n.complete() }, void 0, () => { r = null })) }) } function Zi(e, t) { let n = arguments.length >= 2; return r => r.pipe(e ? Ie((o, i) => e(o, i, r)) : pe, Yt(1), n ? tt(t) : co(() => new He)) } function Yi(e, t) { return R(wl(e, t, arguments.length >= 2, !0)) } function Ki(...e) { let t = Xe(e); return R((n, r) => { (t ? Qt(e, n, t) : Qt(e, n)).subscribe(r) }) } function le(e, t) { return R((n, r) => { let o = null, i = 0, s = !1, a = () => s && !o && r.complete(); n.subscribe(A(r, c => { o?.unsubscribe(); let l = 0, p = i++; W(e(c, p)).subscribe(o = A(r, h => r.next(t ? t(c, h, p, l++) : h), () => { o = null, a() })) }, () => { s = !0, a() })) }) } function lo(e) { return R((t, n) => { W(e).subscribe(A(n, () => n.complete(), xn)), !n.closed && t.subscribe(n) }) } function Q(e, t, n) { let r = b(e) || t || n ? { next: e, error: t, complete: n } : e; return r ? R((o, i) => { var s; (s = r.subscribe) === null || s === void 0 || s.call(r); let a = !0; o.subscribe(A(i, c => { var l; (l = r.next) === null || l === void 0 || l.call(r, c), i.next(c) }, () => { var c; a = !1, (c = r.complete) === null || c === void 0 || c.call(r), i.complete() }, c => { var l; a = !1, (l = r.error) === null || l === void 0 || l.call(r, c), i.error(c) }, () => { var c, l; a && ((c = r.unsubscribe) === null || c === void 0 || c.call(r)), (l = r.finalize) === null || l === void 0 || l.call(r) })) }) : pe } function Dl(e) { let t = x(null); try { return e() } finally { x(t) } } var E = class extends Error { code; constructor(t, n) { super(Ln(t, n)), this.code = t } }; function rh(e) { return `NG0${Math.abs(e)}` } function Ln(e, t) { return `${rh(e)}${t ? ": " + t : ""}` } function P(e) { for (let t in e) if (e[t] === P) return t; throw Error("") } function nt(e) {
  if (typeof e == "string") return e; if (Array.isArray(e)) return `[${e.map(nt).join(", ")}]`; if (e == null) return "" + e; let t = e.overriddenName || e.name; if (t) return `${t}`; let n = e.toString(); if (n == null) return "" + n; let r = n.indexOf(`
`); return r >= 0 ? n.slice(0, r) : n
} function ls(e, t) { return e ? t ? `${e} ${t}` : e : t || "" } var oh = P({ __forward_ref__: P }); function go(e) { return e.__forward_ref__ = go, e.toString = function () { return nt(this()) }, e } function ue(e) { return us(e) ? e() : e } function us(e) { return typeof e == "function" && e.hasOwnProperty(oh) && e.__forward_ref__ === go } function S(e) { return { token: e.token, providedIn: e.providedIn || null, factory: e.factory, value: void 0 } } function Fn(e) { return ih(e, mo) } function ds(e) { return Fn(e) !== null } function ih(e, t) { return e.hasOwnProperty(t) && e[t] || null } function sh(e) { let t = e?.[mo] ?? null; return t || null } function Xi(e) { return e && e.hasOwnProperty(fo) ? e[fo] : null } var mo = P({ \u0275prov: P }), fo = P({ \u0275inj: P }), I = class { _desc; ngMetadataName = "InjectionToken"; \u0275prov; constructor(t, n) { this._desc = t, this.\u0275prov = void 0, typeof n == "number" ? this.__NG_ELEMENT_ID__ = n : n !== void 0 && (this.\u0275prov = S({ token: this, providedIn: n.providedIn || "root", factory: n.factory })) } get multi() { return this } toString() { return `InjectionToken ${this._desc}` } }; function fs(e) { return e && !!e.\u0275providers } var ps = P({ \u0275cmp: P }), hs = P({ \u0275dir: P }), gs = P({ \u0275pipe: P }), ms = P({ \u0275mod: P }), kn = P({ \u0275fac: P }), St = P({ __NG_ELEMENT_ID__: P }), Cl = P({ __NG_ENV_ID__: P }); function Ml(e) { return typeof e == "string" ? e : e == null ? "" : String(e) } function _l(e) { return typeof e == "function" ? e.name || e.toString() : typeof e == "object" && e != null && typeof e.type == "function" ? e.type.name || e.type.toString() : Ml(e) } var Nl = P({ ngErrorCode: P }), ah = P({ ngErrorMessage: P }), ch = P({ ngTokenPath: P }); function vs(e, t) { return xl("", -200, t) } function vo(e, t) { throw new E(-201, !1) } function xl(e, t, n) { let r = new E(t, e); return r[Nl] = t, r[ah] = e, n && (r[ch] = n), r } function lh(e) { return e[Nl] } var es; function Rl() { return es } function he(e) { let t = es; return es = e, t } function ys(e, t, n) { let r = Fn(e); if (r && r.providedIn == "root") return r.value === void 0 ? r.value = r.factory() : r.value; if (n & 8) return null; if (t !== void 0) return t; vo(e, "Injector") } var uh = {}, mt = uh, dh = "__NG_DI_FLAG__", ts = class { injector; constructor(t) { this.injector = t } retrieve(t, n) { let r = vt(n) || 0; try { return this.injector.get(t, r & 8 ? null : mt, r) } catch (o) { if (Ft(o)) return o; throw o } } }; function fh(e, t = 0) { let n = jr(); if (n === void 0) throw new E(-203, !1); if (n === null) return ys(e, void 0, t); { let r = ph(t), o = n.retrieve(e, r); if (Ft(o)) { if (r.optional) return null; throw o } return o } } function M(e, t = 0) { return (Rl() || fh)(ue(e), t) } function m(e, t) { return M(e, vt(t)) } function vt(e) { return typeof e > "u" || typeof e == "number" ? e : 0 | (e.optional && 8) | (e.host && 1) | (e.self && 2) | (e.skipSelf && 4) } function ph(e) { return { optional: !!(e & 8), host: !!(e & 1), self: !!(e & 2), skipSelf: !!(e & 4) } } function ns(e) { let t = []; for (let n = 0; n < e.length; n++) { let r = ue(e[n]); if (Array.isArray(r)) { if (r.length === 0) throw new E(900, !1); let o, i = 0; for (let s = 0; s < r.length; s++) { let a = r[s], c = hh(a); typeof c == "number" ? c === -1 ? o = a.token : i |= c : o = a } t.push(M(o, i)) } else t.push(M(r)) } return t } function hh(e) { return e[dh] } function yt(e, t) { let n = e.hasOwnProperty(kn); return n ? e[kn] : null } function yo(e, t) { e.forEach(n => Array.isArray(n) ? yo(n, t) : t(n)) } function Es(e, t, n) { t >= e.length ? e.push(n) : e.splice(t, 0, n) } function jn(e, t) { return t >= e.length - 1 ? e.pop() : e.splice(t, 1)[0] } var wt = {}, Et = [], Be = new I(""), Is = new I("", -1), Ss = new I(""), Pn = class { get(t, n = mt) { if (n === mt) { let o = xl("", -201); throw o.name = "\u0275NotFound", o } return n } }; function ws(e) { return e[ms] || null } function it(e) { return e[ps] || null } function Ds(e) { return e[hs] || null } function Al(e) { return e[gs] || null } function Dt(e) { return { \u0275providers: e } } function Ol(e) { return Dt([{ provide: Be, multi: !0, useValue: e }]) } function kl(...e) { return { \u0275providers: bs(!0, e), \u0275fromNgModule: !0 } } function bs(e, ...t) { let n = [], r = new Set, o, i = s => { n.push(s) }; return yo(t, s => { let a = s; po(a, i, [], r) && (o ||= [], o.push(a)) }), o !== void 0 && Pl(o, i), n } function Pl(e, t) { for (let n = 0; n < e.length; n++) { let { ngModule: r, providers: o } = e[n]; Cs(o, i => { t(i, r) }) } } function po(e, t, n, r) { if (e = ue(e), !e) return !1; let o = null, i = Xi(e), s = !i && it(e); if (!i && !s) { let c = e.ngModule; if (i = Xi(c), i) o = c; else return !1 } else { if (s && !s.standalone) return !1; o = e } let a = r.has(o); if (s) { if (a) return !1; if (r.add(o), s.dependencies) { let c = typeof s.dependencies == "function" ? s.dependencies() : s.dependencies; for (let l of c) po(l, t, n, r) } } else if (i) { if (i.imports != null && !a) { r.add(o); let l; try { yo(i.imports, p => { po(p, t, n, r) && (l ||= [], l.push(p)) }) } finally { } l !== void 0 && Pl(l, t) } if (!a) { let l = yt(o) || (() => new o); t({ provide: o, useFactory: l, deps: Et }, o), t({ provide: Ss, useValue: o, multi: !0 }, o), t({ provide: Be, useValue: () => M(o), multi: !0 }, o) } let c = i.providers; if (c != null && !a) { let l = e; Cs(c, p => { t(p, l) }) } } else return !1; return o !== e && e.providers !== void 0 } function Cs(e, t) { for (let n of e) fs(n) && (n = n.\u0275providers), Array.isArray(n) ? Cs(n, t) : t(n) } var gh = P({ provide: String, useValue: P }); function Ll(e) { return e !== null && typeof e == "object" && gh in e } function mh(e) { return !!(e && e.useExisting) } function vh(e) { return !!(e && e.useFactory) } function ho(e) { return typeof e == "function" } var Hn = new I(""), uo = {}, Tl = {}, Ji; function Vn() { return Ji === void 0 && (Ji = new Pn), Ji } var J = class { }, It = class extends J { parent; source; scopes; records = new Map; _ngOnDestroyHooks = new Set; _onDestroyHooks = []; get destroyed() { return this._destroyed } _destroyed = !1; injectorDefTypes; constructor(t, n, r, o) { super(), this.parent = n, this.source = r, this.scopes = o, os(t, s => this.processProvider(s)), this.records.set(Is, Kt(void 0, this)), o.has("environment") && this.records.set(J, Kt(void 0, this)); let i = this.records.get(Hn); i != null && typeof i.value == "string" && this.scopes.add(i.value), this.injectorDefTypes = new Set(this.get(Ss, Et, { self: !0 })) } retrieve(t, n) { let r = vt(n) || 0; try { return this.get(t, mt, r) } catch (o) { if (Ft(o)) return o; throw o } } destroy() { On(this), this._destroyed = !0; let t = x(null); try { for (let r of this._ngOnDestroyHooks) r.ngOnDestroy(); let n = this._onDestroyHooks; this._onDestroyHooks = []; for (let r of n) r() } finally { this.records.clear(), this._ngOnDestroyHooks.clear(), this.injectorDefTypes.clear(), x(t) } } onDestroy(t) { return On(this), this._onDestroyHooks.push(t), () => this.removeOnDestroy(t) } runInContext(t) { On(this); let n = Ae(this), r = he(void 0), o; try { return t() } finally { Ae(n), he(r) } } get(t, n = mt, r) { if (On(this), t.hasOwnProperty(Cl)) return t[Cl](this); let o = vt(r), i, s = Ae(this), a = he(void 0); try { if (!(o & 4)) { let l = this.records.get(t); if (l === void 0) { let p = wh(t) && Fn(t); p && this.injectableDefInScope(p) ? l = Kt(rs(t), uo) : l = null, this.records.set(t, l) } if (l != null) return this.hydrate(t, l, o) } let c = o & 2 ? Vn() : this.parent; return n = o & 8 && n === mt ? null : n, c.get(t, n) } catch (c) { let l = lh(c); throw l === -200 || l === -201 ? new E(l, null) : c } finally { he(a), Ae(s) } } resolveInjectorInitializers() { let t = x(null), n = Ae(this), r = he(void 0), o; try { let i = this.get(Be, Et, { self: !0 }); for (let s of i) s() } finally { Ae(n), he(r), x(t) } } toString() { let t = [], n = this.records; for (let r of n.keys()) t.push(nt(r)); return `R3Injector[${t.join(", ")}]` } processProvider(t) { t = ue(t); let n = ho(t) ? t : ue(t && t.provide), r = Eh(t); if (!ho(t) && t.multi === !0) { let o = this.records.get(n); o || (o = Kt(void 0, uo, !0), o.factory = () => ns(o.multi), this.records.set(n, o)), n = t, o.multi.push(t) } this.records.set(n, r) } hydrate(t, n, r) { let o = x(null); try { if (n.value === Tl) throw vs(nt(t)); return n.value === uo && (n.value = Tl, n.value = n.factory(void 0, r)), typeof n.value == "object" && n.value && Sh(n.value) && this._ngOnDestroyHooks.add(n.value), n.value } finally { x(o) } } injectableDefInScope(t) { if (!t.providedIn) return !1; let n = ue(t.providedIn); return typeof n == "string" ? n === "any" || this.scopes.has(n) : this.injectorDefTypes.has(n) } removeOnDestroy(t) { let n = this._onDestroyHooks.indexOf(t); n !== -1 && this._onDestroyHooks.splice(n, 1) } }; function rs(e) { let t = Fn(e), n = t !== null ? t.factory : yt(e); if (n !== null) return n; if (e instanceof I) throw new E(204, !1); if (e instanceof Function) return yh(e); throw new E(204, !1) } function yh(e) { if (e.length > 0) throw new E(204, !1); let n = sh(e); return n !== null ? () => n.factory(e) : () => new e } function Eh(e) { if (Ll(e)) return Kt(void 0, e.useValue); { let t = Fl(e); return Kt(t, uo) } } function Fl(e, t, n) { let r; if (ho(e)) { let o = ue(e); return yt(o) || rs(o) } else if (Ll(e)) r = () => ue(e.useValue); else if (vh(e)) r = () => e.useFactory(...ns(e.deps || [])); else if (mh(e)) r = (o, i) => M(ue(e.useExisting), i !== void 0 && i & 8 ? 8 : void 0); else { let o = ue(e && (e.useClass || e.provide)); if (Ih(e)) r = () => new o(...ns(e.deps)); else return yt(o) || rs(o) } return r } function On(e) { if (e.destroyed) throw new E(205, !1) } function Kt(e, t, n = !1) { return { factory: e, value: t, multi: n ? [] : void 0 } } function Ih(e) { return !!e.deps } function Sh(e) { return e !== null && typeof e == "object" && typeof e.ngOnDestroy == "function" } function wh(e) { return typeof e == "function" || typeof e == "object" && e.ngMetadataName === "InjectionToken" } function os(e, t) { for (let n of e) Array.isArray(n) ? os(n, t) : n && fs(n) ? os(n.\u0275providers, t) : t(n) } function oe(e, t) { let n; e instanceof It ? (On(e), n = e) : n = new ts(e); let r, o = Ae(n), i = he(void 0); try { return t() } finally { Ae(o), he(i) } } function jl() { return Rl() !== void 0 || jr() != null } var Me = 0, _ = 1, T = 2, X = 3, Se = 4, we = 5, Un = 6, Eo = 7, ge = 8, bt = 9, ze = 10, me = 11, Jt = 12, Ts = 13, Xt = 14, De = 15, en = 16, Ct = 17, $n = 18, Bn = 19, Ms = 20, $e = 21, Io = 22, zn = 23, ve = 24, So = 25, qn = 26, be = 27, Hl = 1; var st = 7, Gn = 8, Wn = 9, de = 10; function qe(e) { return Array.isArray(e) && typeof e[Hl] == "object" } function _e(e) { return Array.isArray(e) && e[Hl] === !0 } function _s(e) { return (e.flags & 4) !== 0 } function tn(e) { return e.componentOffset > -1 } function Ns(e) { return (e.flags & 1) === 1 } function Tt(e) { return !!e.template } function nn(e) { return (e[T] & 512) !== 0 } function Mt(e) { return (e[T] & 256) === 256 } var xs = "svg", Vl = "math"; function Pe(e) { for (; Array.isArray(e);)e = e[Me]; return e } function at(e, t) { return Pe(t[e.index]) } function Rs(e, t) { return e.data[t] } function Ge(e, t) { let n = t[e]; return qe(n) ? n : n[Me] } function wo(e) { return (e[T] & 128) === 128 } function Ul(e) { return _e(e[X]) } function Qn(e, t) { return t == null ? null : e[t] } function As(e) { e[Ct] = 0 } function Os(e) { e[T] & 1024 || (e[T] |= 1024, wo(e) && Yn(e)) } function Zn(e) { return !!(e[T] & 9216 || e[ve]?.dirty) } function Do(e) { e[ze].changeDetectionScheduler?.notify(8), e[T] & 64 && (e[T] |= 1024), Zn(e) && Yn(e) } function Yn(e) { e[ze].changeDetectionScheduler?.notify(0); let t = rt(e); for (; t !== null && !(t[T] & 8192 || (t[T] |= 8192, !wo(t)));)t = rt(t) } function ks(e, t) { if (Mt(e)) throw new E(911, !1); e[$e] === null && (e[$e] = []), e[$e].push(t) } function $l(e, t) { if (e[$e] === null) return; let n = e[$e].indexOf(t); n !== -1 && e[$e].splice(n, 1) } function rt(e) { let t = e[X]; return _e(t) ? t[X] : t } var L = { lFrame: eu(null), bindingsEnabled: !0, skipHydrationRootTNode: null }; var is = !1; function Bl() { return L.lFrame.elementDepthCount } function zl() { L.lFrame.elementDepthCount++ } function Ps() { L.lFrame.elementDepthCount-- } function ql() { return L.bindingsEnabled } function Gl() { return L.skipHydrationRootTNode !== null } function Ls(e) { return L.skipHydrationRootTNode === e } function Fs() { L.skipHydrationRootTNode = null } function ye() { return L.lFrame.lView } function js() { return L.lFrame.tView } function Le() { let e = Hs(); for (; e !== null && e.type === 64;)e = e.parent; return e } function Hs() { return L.lFrame.currentTNode } function Wl() { let e = L.lFrame, t = e.currentTNode; return e.isParent ? t : t.parent } function Kn(e, t) { let n = L.lFrame; n.currentTNode = e, n.isParent = t } function Vs() { return L.lFrame.isParent } function Ql() { L.lFrame.isParent = !1 } function Us() { return is } function $s(e) { let t = is; return is = e, t } function Zl(e) { return L.lFrame.bindingIndex = e } function Yl() { return L.lFrame.inI18n } function Kl(e, t) { let n = L.lFrame; n.bindingIndex = n.bindingRootIndex = e, bo(t) } function Jl() { return L.lFrame.currentDirectiveIndex } function bo(e) { L.lFrame.currentDirectiveIndex = e } function Bs(e) { L.lFrame.currentQueryIndex = e } function Dh(e) { let t = e[_]; return t.type === 2 ? t.declTNode : t.type === 1 ? e[we] : null } function zs(e, t, n) { if (n & 4) { let o = t, i = e; for (; o = o.parent, o === null && !(n & 1);)if (o = Dh(i), o === null || (i = i[Xt], o.type & 10)) break; if (o === null) return !1; t = o, e = i } let r = L.lFrame = Xl(); return r.currentTNode = t, r.lView = e, !0 } function Co(e) { let t = Xl(), n = e[_]; L.lFrame = t, t.currentTNode = n.firstChild, t.lView = e, t.tView = n, t.contextLView = e, t.bindingIndex = n.bindingStartIndex, t.inI18n = !1 } function Xl() { let e = L.lFrame, t = e === null ? null : e.child; return t === null ? eu(e) : t } function eu(e) { let t = { currentTNode: null, isParent: !0, lView: null, tView: null, selectedIndex: -1, contextLView: null, elementDepthCount: 0, currentNamespace: null, currentDirectiveIndex: -1, bindingRootIndex: -1, bindingIndex: -1, currentQueryIndex: 0, parent: e, child: null, inI18n: !1 }; return e !== null && (e.child = t), t } function tu() { let e = L.lFrame; return L.lFrame = e.parent, e.currentTNode = null, e.lView = null, e } var qs = tu; function To() { let e = tu(); e.isParent = !0, e.tView = null, e.selectedIndex = -1, e.contextLView = null, e.elementDepthCount = 0, e.currentDirectiveIndex = -1, e.currentNamespace = null, e.bindingRootIndex = -1, e.bindingIndex = -1, e.currentQueryIndex = 0 } function nu() { return L.lFrame.selectedIndex } function ct(e) { L.lFrame.selectedIndex = e } function ee() { L.lFrame.currentNamespace = xs } function te() { bh() } function bh() { L.lFrame.currentNamespace = null } function ru() { return L.lFrame.currentNamespace } var ou = !0; function Gs() { return ou } function Ws(e) { ou = e } function ss(e, t = null, n = null, r) { let o = Qs(e, t, n, r); return o.resolveInjectorInitializers(), o } function Qs(e, t = null, n = null, r, o = new Set) { let i = [n || Et, kl(e)]; return r = r || (typeof e == "object" ? void 0 : nt(e)), new It(i, t || Vn(), r || null, o) } var Oe = class e { static THROW_IF_NOT_FOUND = mt; static NULL = new Pn; static create(t, n) { if (Array.isArray(t)) return ss({ name: "" }, n, t, ""); { let r = t.name ?? ""; return ss({ name: r }, t.parent, t.providers, r) } } static \u0275prov = S({ token: e, providedIn: "any", factory: () => M(Is) }); static __NG_ELEMENT_ID__ = -1 }, Z = new I(""), _t = (() => { class e { static __NG_ELEMENT_ID__ = Ch; static __NG_ENV_ID__ = n => n } return e })(), as = class extends _t { _lView; constructor(t) { super(), this._lView = t } get destroyed() { return Mt(this._lView) } onDestroy(t) { let n = this._lView; return ks(n, t), () => $l(n, t) } }; function Ch() { return new as(ye()) } var ke = class { _console = console; handleError(t) { this._console.error("ERROR", t) } }, Ne = new I("", { providedIn: "root", factory: () => { let e = m(J), t; return n => { e.destroyed && !t ? setTimeout(() => { throw n }) : (t ??= e.get(ke), t.handleError(n)) } } }), iu = { provide: Be, useValue: () => void m(ke), multi: !0 }, Th = new I("", { providedIn: "root", factory: () => { let e = m(Z).defaultView; if (!e) return; let t = m(Ne), n = i => { t(i.reason), i.preventDefault() }, r = i => { i.error ? t(i.error) : t(new Error(i.message, { cause: i })), i.preventDefault() }, o = () => { e.addEventListener("unhandledrejection", n), e.addEventListener("error", r) }; typeof Zone < "u" ? Zone.root.run(o) : o(), m(_t).onDestroy(() => { e.removeEventListener("error", r), e.removeEventListener("unhandledrejection", n) }) } }); function Zs() { return Dt([Ol(() => void m(Th))]) } function Jn(e, t) { let [n, r, o] = Fi(e, t?.equal), i = n, s = i[se]; return i.set = r, i.update = o, i.asReadonly = su.bind(i), i } function su() { let e = this[se]; if (e.readonlyFn === void 0) { let t = () => this(); t[se] = e, e.readonlyFn = t } return e.readonlyFn } var ot = class { }, Xn = new I("", { providedIn: "root", factory: () => !1 }); var Ys = new I(""), Mo = new I(""), We = (() => { class e { taskId = 0; pendingTasks = new Set; destroyed = !1; pendingTask = new K(!1); get hasPendingTasks() { return this.destroyed ? !1 : this.pendingTask.value } get hasPendingTasksObservable() { return this.destroyed ? new k(n => { n.next(!1), n.complete() }) : this.pendingTask } add() { !this.hasPendingTasks && !this.destroyed && this.pendingTask.next(!0); let n = this.taskId++; return this.pendingTasks.add(n), n } has(n) { return this.pendingTasks.has(n) } remove(n) { this.pendingTasks.delete(n), this.pendingTasks.size === 0 && this.hasPendingTasks && this.pendingTask.next(!1) } ngOnDestroy() { this.pendingTasks.clear(), this.hasPendingTasks && this.pendingTask.next(!1), this.destroyed = !0, this.pendingTask.unsubscribe() } static \u0275prov = S({ token: e, providedIn: "root", factory: () => new e }) } return e })(); function er(...e) { } var Ks = (() => { class e { static \u0275prov = S({ token: e, providedIn: "root", factory: () => new cs }) } return e })(), cs = class { dirtyEffectCount = 0; queues = new Map; add(t) { this.enqueue(t), this.schedule(t) } schedule(t) { t.dirty && this.dirtyEffectCount++ } remove(t) { let n = t.zone, r = this.queues.get(n); r.has(t) && (r.delete(t), t.dirty && this.dirtyEffectCount--) } enqueue(t) { let n = t.zone; this.queues.has(n) || this.queues.set(n, new Set); let r = this.queues.get(n); r.has(t) || r.add(t) } flush() { for (; this.dirtyEffectCount > 0;) { let t = !1; for (let [n, r] of this.queues) n === null ? t ||= this.flushQueue(r) : t ||= n.run(() => this.flushQueue(r)); t || (this.dirtyEffectCount = 0) } } flushQueue(t) { let n = !1; for (let r of t) r.dirty && (this.dirtyEffectCount--, n = !0, r.run()); return n } }; function $o(e) { return { toString: e }.toString() } function Hh(e) { return typeof e == "function" } var Ro = class { previousValue; currentValue; firstChange; constructor(t, n, r) { this.previousValue = t, this.currentValue = n, this.firstChange = r } isFirstChange() { return this.firstChange } }; function ku(e, t, n, r) { t !== null ? t.applyValueToInputSignal(t, r) : e[n] = r } var ya = (() => { let e = () => Pu; return e.ngInherit = !0, e })(); function Pu(e) { return e.type.prototype.ngOnChanges && (e.setInput = Uh), Vh } function Vh() { let e = Fu(this), t = e?.current; if (t) { let n = e.previous; if (n === wt) e.previous = t; else for (let r in t) n[r] = t[r]; e.current = null, this.ngOnChanges(t) } } function Uh(e, t, n, r, o) { let i = this.declaredInputs[r], s = Fu(e) || $h(e, { previous: wt, current: null }), a = s.current || (s.current = {}), c = s.previous, l = c[i]; a[i] = new Ro(l && l.currentValue, n, c === wt), ku(e, t, o, n) } var Lu = "__ngSimpleChanges__"; function Fu(e) { return e[Lu] || null } function $h(e, t) { return e[Lu] = t } var au = []; var U = function (e, t = null, n) { for (let r = 0; r < au.length; r++) { let o = au[r]; o(e, t, n) } }; function Bh(e, t, n) { let { ngOnChanges: r, ngOnInit: o, ngDoCheck: i } = t.type.prototype; if (r) { let s = Pu(t); (n.preOrderHooks ??= []).push(e, s), (n.preOrderCheckHooks ??= []).push(e, s) } o && (n.preOrderHooks ??= []).push(0 - e, o), i && ((n.preOrderHooks ??= []).push(e, i), (n.preOrderCheckHooks ??= []).push(e, i)) } function zh(e, t) { for (let n = t.directiveStart, r = t.directiveEnd; n < r; n++) { let i = e.data[n].type.prototype, { ngAfterContentInit: s, ngAfterContentChecked: a, ngAfterViewInit: c, ngAfterViewChecked: l, ngOnDestroy: p } = i; s && (e.contentHooks ??= []).push(-n, s), a && ((e.contentHooks ??= []).push(n, a), (e.contentCheckHooks ??= []).push(n, a)), c && (e.viewHooks ??= []).push(-n, c), l && ((e.viewHooks ??= []).push(n, l), (e.viewCheckHooks ??= []).push(n, l)), p != null && (e.destroyHooks ??= []).push(n, p) } } function _o(e, t, n) { ju(e, t, 3, n) } function No(e, t, n, r) { (e[T] & 3) === n && ju(e, t, n, r) } function Js(e, t) { let n = e[T]; (n & 3) === t && (n &= 16383, n += 1, e[T] = n) } function ju(e, t, n, r) { let o = r !== void 0 ? e[Ct] & 65535 : 0, i = r ?? -1, s = t.length - 1, a = 0; for (let c = o; c < s; c++)if (typeof t[c + 1] == "number") { if (a = t[c], r != null && a >= r) break } else t[c] < 0 && (e[Ct] += 65536), (a < i || i == -1) && (qh(e, n, t, c), e[Ct] = (e[Ct] & 4294901760) + c + 2), c++ } function cu(e, t) { U(4, e, t); let n = x(null); try { t.call(e) } finally { x(n), U(5, e, t) } } function qh(e, t, n, r) { let o = n[r] < 0, i = n[r + 1], s = o ? -n[r] : n[r], a = e[s]; o ? e[T] >> 14 < e[Ct] >> 16 && (e[T] & 3) === t && (e[T] += 16384, cu(a, i)) : cu(a, i) } var on = -1, rr = class { factory; name; injectImpl; resolving = !1; canSeeViewProviders; multi; componentProviders; index; providerFactory; constructor(t, n, r, o) { this.factory = t, this.name = o, this.canSeeViewProviders = n, this.injectImpl = r } }; function Gh(e) { return (e.flags & 8) !== 0 } function Wh(e) { return (e.flags & 16) !== 0 } function Qh(e, t, n) { let r = 0; for (; r < n.length;) { let o = n[r]; if (typeof o == "number") { if (o !== 0) break; r++; let i = n[r++], s = n[r++], a = n[r++]; e.setAttribute(t, s, a, i) } else { let i = o, s = n[++r]; Yh(i) ? e.setProperty(t, i, s) : e.setAttribute(t, i, s), r++ } } return r } function Zh(e) { return e === 3 || e === 4 || e === 6 } function Yh(e) { return e.charCodeAt(0) === 64 } function Ea(e, t) { if (!(t === null || t.length === 0)) if (e === null || e.length === 0) e = t.slice(); else { let n = -1; for (let r = 0; r < t.length; r++) { let o = t[r]; typeof o == "number" ? n = o : n === 0 || (n === -1 || n === 2 ? lu(e, n, o, null, t[++r]) : lu(e, n, o, null, null)) } } return e } function lu(e, t, n, r, o) { let i = 0, s = e.length; if (t === -1) s = -1; else for (; i < e.length;) { let a = e[i++]; if (typeof a == "number") { if (a === t) { s = -1; break } else if (a > t) { s = i - 1; break } } } for (; i < e.length;) { let a = e[i]; if (typeof a == "number") break; if (a === n) { o !== null && (e[i + 1] = o); return } i++, o !== null && i++ } s !== -1 && (e.splice(s, 0, t), i = s + 1), e.splice(i++, 0, n), o !== null && e.splice(i++, 0, o) } function Hu(e) { return e !== on } function Ao(e) { return e & 32767 } function Kh(e) { return e >> 16 } function Oo(e, t) { let n = Kh(e), r = t; for (; n > 0;)r = r[Xt], n--; return r } var na = !0; function uu(e) { let t = na; return na = e, t } var Jh = 256, Vu = Jh - 1, Uu = 5, Xh = 0, Fe = {}; function eg(e, t, n) { let r; typeof n == "string" ? r = n.charCodeAt(0) || 0 : n.hasOwnProperty(St) && (r = n[St]), r == null && (r = n[St] = Xh++); let o = r & Vu, i = 1 << o; t.data[e + (o >> Uu)] |= i } function $u(e, t) { let n = Bu(e, t); if (n !== -1) return n; let r = t[_]; r.firstCreatePass && (e.injectorIndex = t.length, Xs(r.data, e), Xs(t, null), Xs(r.blueprint, null)); let o = Ia(e, t), i = e.injectorIndex; if (Hu(o)) { let s = Ao(o), a = Oo(o, t), c = a[_].data; for (let l = 0; l < 8; l++)t[i + l] = a[s + l] | c[s + l] } return t[i + 8] = o, i } function Xs(e, t) { e.push(0, 0, 0, 0, 0, 0, 0, 0, t) } function Bu(e, t) { return e.injectorIndex === -1 || e.parent && e.parent.injectorIndex === e.injectorIndex || t[e.injectorIndex + 8] === null ? -1 : e.injectorIndex } function Ia(e, t) { if (e.parent && e.parent.injectorIndex !== -1) return e.parent.injectorIndex; let n = 0, r = null, o = t; for (; o !== null;) { if (r = Qu(o), r === null) return on; if (n++, o = o[Xt], r.injectorIndex !== -1) return r.injectorIndex | n << 16 } return on } function tg(e, t, n) { eg(e, t, n) } function zu(e, t, n) { if (n & 8 || e !== void 0) return e; vo(t, "NodeInjector") } function qu(e, t, n, r) { if (n & 8 && r === void 0 && (r = null), (n & 3) === 0) { let o = e[bt], i = he(void 0); try { return o ? o.get(t, r, n & 8) : ys(t, r, n & 8) } finally { he(i) } } return zu(r, t, n) } function Gu(e, t, n, r = 0, o) { if (e !== null) { if (t[T] & 2048 && !(r & 2)) { let s = sg(e, t, n, r, Fe); if (s !== Fe) return s } let i = Wu(e, t, n, r, Fe); if (i !== Fe) return i } return qu(t, n, r, o) } function Wu(e, t, n, r, o) { let i = og(n); if (typeof i == "function") { if (!zs(t, e, r)) return r & 1 ? zu(o, n, r) : qu(t, n, r, o); try { let s; if (s = i(r), s == null && !(r & 8)) vo(n); else return s } finally { qs() } } else if (typeof i == "number") { let s = null, a = Bu(e, t), c = on, l = r & 1 ? t[De][we] : null; for ((a === -1 || r & 4) && (c = a === -1 ? Ia(e, t) : t[a + 8], c === on || !fu(r, !1) ? a = -1 : (s = t[_], a = Ao(c), t = Oo(c, t))); a !== -1;) { let p = t[_]; if (du(i, a, p.data)) { let h = ng(a, t, n, s, r, l); if (h !== Fe) return h } c = t[a + 8], c !== on && fu(r, t[_].data[a + 8] === l) && du(i, a, t) ? (s = p, a = Ao(c), t = Oo(c, t)) : a = -1 } } return o } function ng(e, t, n, r, o, i) { let s = t[_], a = s.data[e + 8], c = r == null ? tn(a) && na : r != s && (a.type & 3) !== 0, l = o & 1 && i === a, p = rg(a, s, n, c, l); return p !== null ? ra(t, s, p, a, o) : Fe } function rg(e, t, n, r, o) { let i = e.providerIndexes, s = t.data, a = i & 1048575, c = e.directiveStart, l = e.directiveEnd, p = i >> 20, h = r ? a : a + p, v = o ? a + p : l; for (let g = h; g < v; g++) { let w = s[g]; if (g < c && n === w || g >= c && w.type === n) return g } if (o) { let g = s[c]; if (g && Tt(g) && g.type === n) return c } return null } function ra(e, t, n, r, o) { let i = e[n], s = t.data; if (i instanceof rr) { let a = i; if (a.resolving) { let g = _l(s[n]); throw vs(g) } let c = uu(a.canSeeViewProviders); a.resolving = !0; let l = s[n].type || s[n], p, h = a.injectImpl ? he(a.injectImpl) : null, v = zs(e, r, 0); try { i = e[n] = a.factory(void 0, o, s, e, r), t.firstCreatePass && n >= r.directiveStart && Bh(n, s[n], t) } finally { h !== null && he(h), uu(c), a.resolving = !1, qs() } } return i } function og(e) { if (typeof e == "string") return e.charCodeAt(0) || 0; let t = e.hasOwnProperty(St) ? e[St] : void 0; return typeof t == "number" ? t >= 0 ? t & Vu : ig : t } function du(e, t, n) { let r = 1 << e; return !!(n[t + (e >> Uu)] & r) } function fu(e, t) { return !(e & 2) && !(e & 1 && t) } var Nt = class { _tNode; _lView; constructor(t, n) { this._tNode = t, this._lView = n } get(t, n, r) { return Gu(this._tNode, this._lView, t, vt(r), n) } }; function ig() { return new Nt(Le(), ye()) } function Bo(e) { return $o(() => { let t = e.prototype.constructor, n = t[kn] || oa(t), r = Object.prototype, o = Object.getPrototypeOf(e.prototype).constructor; for (; o && o !== r;) { let i = o[kn] || oa(o); if (i && i !== n) return i; o = Object.getPrototypeOf(o) } return i => new i }) } function oa(e) { return us(e) ? () => { let t = oa(ue(e)); return t && t() } : yt(e) } function sg(e, t, n, r, o) { let i = e, s = t; for (; i !== null && s !== null && s[T] & 2048 && !nn(s);) { let a = Wu(i, s, n, r | 2, Fe); if (a !== Fe) return a; let c = i.parent; if (!c) { let l = s[Ms]; if (l) { let p = l.get(n, Fe, r); if (p !== Fe) return p } c = Qu(s), s = s[Xt] } i = c } return o } function Qu(e) { let t = e[_], n = t.type; return n === 2 ? t.declTNode : n === 1 ? e[we] : null } function ag() { return Sa(Le(), ye()) } function Sa(e, t) { return new Zu(at(e, t)) } var Zu = (() => { class e { nativeElement; constructor(n) { this.nativeElement = n } static __NG_ELEMENT_ID__ = ag } return e })(); function Yu(e) { return (e.flags & 128) === 128 } var wa = (function (e) { return e[e.OnPush = 0] = "OnPush", e[e.Default = 1] = "Default", e })(wa || {}), Ku = new Map, cg = 0; function lg() { return cg++ } function ug(e) { Ku.set(e[Bn], e) } function ia(e) { Ku.delete(e[Bn]) } var pu = "__ngContext__"; function or(e, t) { qe(t) ? (e[pu] = t[Bn], ug(t)) : e[pu] = t } function Ju(e) { return ed(e[Jt]) } function Xu(e) { return ed(e[Se]) } function ed(e) { for (; e !== null && !_e(e);)e = e[Se]; return e } var sa; function Da(e) { sa = e } function td() { if (sa !== void 0) return sa; if (typeof document < "u") return document; throw new E(210, !1) } var zo = new I("", { providedIn: "root", factory: () => dg }), dg = "ng", qo = new I(""), cr = new I("", { providedIn: "platform", factory: () => "unknown" }); var Go = new I("", { providedIn: "root", factory: () => td().body?.querySelector("[ngCspNonce]")?.getAttribute("ngCspNonce") || null }); var fg = "h", pg = "b"; var nd = !1, rd = new I("", { providedIn: "root", factory: () => nd }); function ba(e) { return (e.flags & 32) === 32 } var hg = () => null; function od(e, t, n = !1) { return hg(e, t, n) } function id(e, t) { let n = e.contentQueries; if (n !== null) { let r = x(null); try { for (let o = 0; o < n.length; o += 2) { let i = n[o], s = n[o + 1]; if (s !== -1) { let a = e.data[s]; Bs(i), a.contentQueries(2, t[s], s) } } } finally { x(r) } } } function aa(e, t, n) { Bs(0); let r = x(null); try { t(e, n) } finally { x(r) } } function sd(e, t, n) { if (_s(t)) { let r = x(null); try { let o = t.directiveStart, i = t.directiveEnd; for (let s = o; s < i; s++) { let a = e.data[s]; if (a.contentQueries) { let c = n[s]; a.contentQueries(1, c, s) } } } finally { x(r) } } } var Qe = (function (e) { return e[e.Emulated = 0] = "Emulated", e[e.None = 2] = "None", e[e.ShadowDom = 3] = "ShadowDom", e })(Qe || {}); function gg(e, t) { return e.createText(t) } function ad(e, t, n) { return e.createElement(t, n) } function ko(e, t, n, r, o) { e.insertBefore(t, n, r, o) } function cd(e, t, n) { e.appendChild(t, n) } function hu(e, t, n, r, o) { r !== null ? ko(e, t, n, r, o) : cd(e, t, n) } function mg(e, t, n, r) { e.removeChild(null, t, n, r) } function vg(e, t, n) { e.setAttribute(t, "style", n) } function yg(e, t, n) { n === "" ? e.removeAttribute(t, "class") : e.setAttribute(t, "class", n) } function ld(e, t, n) { let { mergedAttrs: r, classes: o, styles: i } = n; r !== null && Qh(e, t, r), o !== null && yg(e, t, o), i !== null && vg(e, t, i) } function ud(e) { return e instanceof Function ? e() : e } function Eg(e, t, n) { let r = e.length; for (; ;) { let o = e.indexOf(t, n); if (o === -1) return o; if (o === 0 || e.charCodeAt(o - 1) <= 32) { let i = t.length; if (o + i === r || e.charCodeAt(o + i) <= 32) return o } n = o + 1 } } var dd = "ng-template"; function Ig(e, t, n, r) { let o = 0; if (r) { for (; o < t.length && typeof t[o] == "string"; o += 2)if (t[o] === "class" && Eg(t[o + 1].toLowerCase(), n, 0) !== -1) return !0 } else if (Ca(e)) return !1; if (o = t.indexOf(1, o), o > -1) { let i; for (; ++o < t.length && typeof (i = t[o]) == "string";)if (i.toLowerCase() === n) return !0 } return !1 } function Ca(e) { return e.type === 4 && e.value !== dd } function Sg(e, t, n) { let r = e.type === 4 && !n ? dd : e.value; return t === r } function wg(e, t, n) { let r = 4, o = e.attrs, i = o !== null ? Cg(o) : 0, s = !1; for (let a = 0; a < t.length; a++) { let c = t[a]; if (typeof c == "number") { if (!s && !xe(r) && !xe(c)) return !1; if (s && xe(c)) continue; s = !1, r = c | r & 1; continue } if (!s) if (r & 4) { if (r = 2 | r & 1, c !== "" && !Sg(e, c, n) || c === "" && t.length === 1) { if (xe(r)) return !1; s = !0 } } else if (r & 8) { if (o === null || !Ig(e, o, c, n)) { if (xe(r)) return !1; s = !0 } } else { let l = t[++a], p = Dg(c, o, Ca(e), n); if (p === -1) { if (xe(r)) return !1; s = !0; continue } if (l !== "") { let h; if (p > i ? h = "" : h = o[p + 1].toLowerCase(), r & 2 && l !== h) { if (xe(r)) return !1; s = !0 } } } } return xe(r) || s } function xe(e) { return (e & 1) === 0 } function Dg(e, t, n, r) { if (t === null) return -1; let o = 0; if (r || !n) { let i = !1; for (; o < t.length;) { let s = t[o]; if (s === e) return o; if (s === 3 || s === 6) i = !0; else if (s === 1 || s === 2) { let a = t[++o]; for (; typeof a == "string";)a = t[++o]; continue } else { if (s === 4) break; if (s === 0) { o += 4; continue } } o += i ? 1 : 2 } return -1 } else return Tg(t, e) } function bg(e, t, n = !1) { for (let r = 0; r < t.length; r++)if (wg(e, t[r], n)) return !0; return !1 } function Cg(e) { for (let t = 0; t < e.length; t++) { let n = e[t]; if (Zh(n)) return t } return e.length } function Tg(e, t) { let n = e.indexOf(4); if (n > -1) for (n++; n < e.length;) { let r = e[n]; if (typeof r == "number") return -1; if (r === t) return n; n++ } return -1 } function gu(e, t) { return e ? ":not(" + t.trim() + ")" : t } function Mg(e) { let t = e[0], n = 1, r = 2, o = "", i = !1; for (; n < e.length;) { let s = e[n]; if (typeof s == "string") if (r & 2) { let a = e[++n]; o += "[" + s + (a.length > 0 ? '="' + a + '"' : "") + "]" } else r & 8 ? o += "." + s : r & 4 && (o += " " + s); else o !== "" && !xe(s) && (t += gu(i, o), o = ""), r = s, i = i || !xe(r); n++ } return o !== "" && (t += gu(i, o)), t } function _g(e) { return e.map(Mg).join(",") } function Ng(e) { let t = [], n = [], r = 1, o = 2; for (; r < e.length;) { let i = e[r]; if (typeof i == "string") o === 2 ? i !== "" && t.push(i, e[++r]) : o === 8 && n.push(i); else { if (!xe(o)) break; o = i } r++ } return n.length && t.push(1, ...n), t } var Ta = {}; function fd(e, t, n, r, o, i, s, a, c, l, p) { let h = be + r, v = h + o, g = xg(h, v), w = typeof l == "function" ? l() : l; return g[_] = { type: e, blueprint: g, template: n, queries: null, viewQuery: a, declTNode: t, data: g.slice().fill(null, h), bindingStartIndex: h, expandoStartIndex: v, hostBindingOpCodes: null, firstCreatePass: !0, firstUpdatePass: !0, staticViewQueries: !1, staticContentQueries: !1, preOrderHooks: null, preOrderCheckHooks: null, contentHooks: null, contentCheckHooks: null, viewHooks: null, viewCheckHooks: null, destroyHooks: null, cleanup: null, contentQueries: null, components: null, directiveRegistry: typeof i == "function" ? i() : i, pipeRegistry: typeof s == "function" ? s() : s, firstChild: null, schemas: c, consts: w, incompleteFirstPass: !1, ssrId: p } } function xg(e, t) { let n = []; for (let r = 0; r < t; r++)n.push(r < e ? null : Ta); return n } function Rg(e) { let t = e.tView; return t === null || t.incompleteFirstPass ? e.tView = fd(1, null, e.template, e.decls, e.vars, e.directiveDefs, e.pipeDefs, e.viewQuery, e.schemas, e.consts, e.id) : t } function pd(e, t, n, r, o, i, s, a, c, l, p) { let h = t.blueprint.slice(); return h[Me] = o, h[T] = r | 4 | 128 | 8 | 64 | 1024, (l !== null || e && e[T] & 2048) && (h[T] |= 2048), As(h), h[X] = h[Xt] = e, h[ge] = n, h[ze] = s || e && e[ze], h[me] = a || e && e[me], h[bt] = c || e && e[bt] || null, h[we] = i, h[Bn] = lg(), h[Un] = p, h[Ms] = l, h[De] = t.type == 2 ? e[De] : h, h } function Ag(e, t, n) { let r = at(t, e), o = Rg(n), i = e[ze].rendererFactory, s = md(e, pd(e, o, null, hd(n), r, t, null, i.createRenderer(r, n), null, null, null)); return e[t.index] = s } function hd(e) { let t = 16; return e.signals ? t = 4096 : e.onPush && (t = 64), t } function gd(e, t, n, r) { if (n === 0) return -1; let o = t.length; for (let i = 0; i < n; i++)t.push(r), e.blueprint.push(r), e.data.push(null); return o } function md(e, t) { return e[Jt] ? e[Ts][Se] = t : e[Jt] = t, e[Ts] = t, t } function Og(e, t, n, r) { if (!r) if ((t[T] & 3) === 3) { let i = e.preOrderCheckHooks; i !== null && _o(t, i, n) } else { let i = e.preOrderHooks; i !== null && No(t, i, 0, n) } ct(n) } var Wo = (function (e) { return e[e.None = 0] = "None", e[e.SignalBased = 1] = "SignalBased", e[e.HasDecoratorInputTransform = 2] = "HasDecoratorInputTransform", e })(Wo || {}); function ca(e, t, n, r) { let o = x(null); try { let [i, s, a] = e.inputs[n], c = null; (s & Wo.SignalBased) !== 0 && (c = t[i][se]), c !== null && c.transformFn !== void 0 ? r = c.transformFn(r) : a !== null && (r = a.call(t, r)), e.setInput !== null ? e.setInput(t, c, r, n, i) : ku(t, c, i, r) } finally { x(o) } } var At = (function (e) { return e[e.Important = 1] = "Important", e[e.DashCase = 2] = "DashCase", e })(At || {}), kg; function Ma(e, t) { return kg(e, t) } var sn = new Set, _a = (function (e) { return e[e.CHANGE_DETECTION = 0] = "CHANGE_DETECTION", e[e.AFTER_NEXT_RENDER = 1] = "AFTER_NEXT_RENDER", e })(_a || {}), lr = new I(""), mu = new Set; function Qo(e) { mu.has(e) || (mu.add(e), performance?.mark?.("mark_feature_usage", { detail: { feature: e } })) } var vd = !1, la = class extends Y { __isAsync; destroyRef = void 0; pendingTasks = void 0; constructor(t = !1) { super(), this.__isAsync = t, jl() && (this.destroyRef = m(_t, { optional: !0 }) ?? void 0, this.pendingTasks = m(We, { optional: !0 }) ?? void 0) } emit(t) { let n = x(null); try { super.next(t) } finally { x(n) } } subscribe(t, n, r) { let o = t, i = n || (() => null), s = r; if (t && typeof t == "object") { let c = t; o = c.next?.bind(c), i = c.error?.bind(c), s = c.complete?.bind(c) } this.__isAsync && (i = this.wrapInTimeout(i), o && (o = this.wrapInTimeout(o)), s && (s = this.wrapInTimeout(s))); let a = super.subscribe({ next: o, error: i, complete: s }); return t instanceof B && t.add(a), a } wrapInTimeout(t) { return n => { let r = this.pendingTasks?.add(); setTimeout(() => { try { t(n) } finally { r !== void 0 && this.pendingTasks?.remove(r) } }) } } }, ie = la; function yd(e) { let t, n; function r() { e = er; try { n !== void 0 && typeof cancelAnimationFrame == "function" && cancelAnimationFrame(n), t !== void 0 && clearTimeout(t) } catch { } } return t = setTimeout(() => { e(), r() }), typeof requestAnimationFrame == "function" && (n = requestAnimationFrame(() => { e(), r() })), () => r() } function vu(e) { return queueMicrotask(() => e()), () => { e = er } } var Na = "isAngularZone", Po = Na + "_ID", Pg = 0, G = class e { hasPendingMacrotasks = !1; hasPendingMicrotasks = !1; isStable = !0; onUnstable = new ie(!1); onMicrotaskEmpty = new ie(!1); onStable = new ie(!1); onError = new ie(!1); constructor(t) { let { enableLongStackTrace: n = !1, shouldCoalesceEventChangeDetection: r = !1, shouldCoalesceRunChangeDetection: o = !1, scheduleInRootZone: i = vd } = t; if (typeof Zone > "u") throw new E(908, !1); Zone.assertZonePatched(); let s = this; s._nesting = 0, s._outer = s._inner = Zone.current, Zone.TaskTrackingZoneSpec && (s._inner = s._inner.fork(new Zone.TaskTrackingZoneSpec)), n && Zone.longStackTraceZoneSpec && (s._inner = s._inner.fork(Zone.longStackTraceZoneSpec)), s.shouldCoalesceEventChangeDetection = !o && r, s.shouldCoalesceRunChangeDetection = o, s.callbackScheduled = !1, s.scheduleInRootZone = i, jg(s) } static isInAngularZone() { return typeof Zone < "u" && Zone.current.get(Na) === !0 } static assertInAngularZone() { if (!e.isInAngularZone()) throw new E(909, !1) } static assertNotInAngularZone() { if (e.isInAngularZone()) throw new E(909, !1) } run(t, n, r) { return this._inner.run(t, n, r) } runTask(t, n, r, o) { let i = this._inner, s = i.scheduleEventTask("NgZoneEvent: " + o, t, Lg, er, er); try { return i.runTask(s, n, r) } finally { i.cancelTask(s) } } runGuarded(t, n, r) { return this._inner.runGuarded(t, n, r) } runOutsideAngular(t) { return this._outer.run(t) } }, Lg = {}; function xa(e) { if (e._nesting == 0 && !e.hasPendingMicrotasks && !e.isStable) try { e._nesting++, e.onMicrotaskEmpty.emit(null) } finally { if (e._nesting--, !e.hasPendingMicrotasks) try { e.runOutsideAngular(() => e.onStable.emit(null)) } finally { e.isStable = !0 } } } function Fg(e) { if (e.isCheckStableRunning || e.callbackScheduled) return; e.callbackScheduled = !0; function t() { yd(() => { e.callbackScheduled = !1, ua(e), e.isCheckStableRunning = !0, xa(e), e.isCheckStableRunning = !1 }) } e.scheduleInRootZone ? Zone.root.run(() => { t() }) : e._outer.run(() => { t() }), ua(e) } function jg(e) { let t = () => { Fg(e) }, n = Pg++; e._inner = e._inner.fork({ name: "angular", properties: { [Na]: !0, [Po]: n, [Po + n]: !0 }, onInvokeTask: (r, o, i, s, a, c) => { if (Hg(c)) return r.invokeTask(i, s, a, c); try { return yu(e), r.invokeTask(i, s, a, c) } finally { (e.shouldCoalesceEventChangeDetection && s.type === "eventTask" || e.shouldCoalesceRunChangeDetection) && t(), Eu(e) } }, onInvoke: (r, o, i, s, a, c, l) => { try { return yu(e), r.invoke(i, s, a, c, l) } finally { e.shouldCoalesceRunChangeDetection && !e.callbackScheduled && !Vg(c) && t(), Eu(e) } }, onHasTask: (r, o, i, s) => { r.hasTask(i, s), o === i && (s.change == "microTask" ? (e._hasPendingMicrotasks = s.microTask, ua(e), xa(e)) : s.change == "macroTask" && (e.hasPendingMacrotasks = s.macroTask)) }, onHandleError: (r, o, i, s) => (r.handleError(i, s), e.runOutsideAngular(() => e.onError.emit(s)), !1) }) } function ua(e) { e._hasPendingMicrotasks || (e.shouldCoalesceEventChangeDetection || e.shouldCoalesceRunChangeDetection) && e.callbackScheduled === !0 ? e.hasPendingMicrotasks = !0 : e.hasPendingMicrotasks = !1 } function yu(e) { e._nesting++, e.isStable && (e.isStable = !1, e.onUnstable.emit(null)) } function Eu(e) { e._nesting--, xa(e) } var ir = class { hasPendingMicrotasks = !1; hasPendingMacrotasks = !1; isStable = !0; onUnstable = new ie; onMicrotaskEmpty = new ie; onStable = new ie; onError = new ie; run(t, n, r) { return t.apply(n, r) } runGuarded(t, n, r) { return t.apply(n, r) } runOutsideAngular(t) { return t() } runTask(t, n, r, o) { return t.apply(n, r) } }; function Hg(e) { return Ed(e, "__ignore_ng_zone__") } function Vg(e) { return Ed(e, "__scheduler_tick__") } function Ed(e, t) { return !Array.isArray(e) || e.length !== 1 ? !1 : e[0]?.data?.[t] === !0 } var Id = (() => { class e { impl = null; execute() { this.impl?.execute() } static \u0275prov = S({ token: e, providedIn: "root", factory: () => new e }) } return e })(); var Ug = new I("", { providedIn: "root", factory: () => ({ queue: new Set, isScheduled: !1, scheduler: null }) }); function Sd(e, t, n) { let r = e.get(Ug); if (Array.isArray(t)) for (let o of t) r.queue.add(o), n?.detachedLeaveAnimationFns?.push(o); else r.queue.add(t), n?.detachedLeaveAnimationFns?.push(t); r.scheduler && r.scheduler(e) } function $g(e, t) { for (let [n, r] of t) Sd(e, r.animateFns) } function Iu(e, t, n, r) { let o = e?.[qn]?.enter; t !== null && o && o.has(n.index) && $g(r, o) } function rn(e, t, n, r, o, i, s, a) { if (o != null) { let c, l = !1; _e(o) ? c = o : qe(o) && (l = !0, o = o[Me]); let p = Pe(o); e === 0 && r !== null ? (Iu(a, r, i, n), s == null ? cd(t, r, p) : ko(t, r, p, s || null, !0)) : e === 1 && r !== null ? (Iu(a, r, i, n), ko(t, r, p, s || null, !0)) : e === 2 ? Su(a, i, n, h => { mg(t, p, l, h) }) : e === 3 && Su(a, i, n, () => { t.destroyNode(p) }), c != null && tm(t, e, n, c, i, r, s) } } function Bg(e, t) { wd(e, t), t[Me] = null, t[we] = null } function zg(e, t, n, r, o, i) { r[Me] = o, r[we] = t, Zo(e, r, n, 1, o, i) } function wd(e, t) { t[ze].changeDetectionScheduler?.notify(9), Zo(e, t, t[me], 2, null, null) } function qg(e) { let t = e[Jt]; if (!t) return ea(e[_], e); for (; t;) { let n = null; if (qe(t)) n = t[Jt]; else { let r = t[de]; r && (n = r) } if (!n) { for (; t && !t[Se] && t !== e;)qe(t) && ea(t[_], t), t = t[X]; t === null && (t = e), qe(t) && ea(t[_], t), n = t && t[Se] } t = n } } function Ra(e, t) { let n = e[Wn], r = n.indexOf(t); n.splice(r, 1) } function Dd(e, t) { if (Mt(t)) return; let n = t[me]; n.destroyNode && Zo(e, t, n, 3, null, null), qg(t) } function ea(e, t) { if (Mt(t)) return; let n = x(null); try { t[T] &= -129, t[T] |= 256, t[ve] && _n(t[ve]), Qg(e, t), Wg(e, t), t[_].type === 1 && t[me].destroy(); let r = t[en]; if (r !== null && _e(t[X])) { r !== t[X] && Ra(r, t); let o = t[$n]; o !== null && o.detachView(e) } ia(t) } finally { x(n) } } function Su(e, t, n, r) { let o = e?.[qn]; if (o == null || o.leave == null || !o.leave.has(t.index)) return r(!1); e && sn.add(e), Sd(n, () => { if (o.leave && o.leave.has(t.index)) { let s = o.leave.get(t.index), a = []; if (s) { for (let c = 0; c < s.animateFns.length; c++) { let l = s.animateFns[c], { promise: p } = l(); a.push(p) } o.detachedLeaveAnimationFns = void 0 } o.running = Promise.allSettled(a), Gg(e, r) } else e && sn.delete(e), r(!1) }, o) } function Gg(e, t) { let n = e[qn]?.running; if (n) { n.then(() => { e[qn].running = void 0, sn.delete(e), t(!0) }); return } t(!1) } function Wg(e, t) { let n = e.cleanup, r = t[Eo]; if (n !== null) for (let s = 0; s < n.length - 1; s += 2)if (typeof n[s] == "string") { let a = n[s + 3]; a >= 0 ? r[a]() : r[-a].unsubscribe(), s += 2 } else { let a = r[n[s + 1]]; n[s].call(a) } r !== null && (t[Eo] = null); let o = t[$e]; if (o !== null) { t[$e] = null; for (let s = 0; s < o.length; s++) { let a = o[s]; a() } } let i = t[zn]; if (i !== null) { t[zn] = null; for (let s of i) s.destroy() } } function Qg(e, t) { let n; if (e != null && (n = e.destroyHooks) != null) for (let r = 0; r < n.length; r += 2) { let o = t[n[r]]; if (!(o instanceof rr)) { let i = n[r + 1]; if (Array.isArray(i)) for (let s = 0; s < i.length; s += 2) { let a = o[i[s]], c = i[s + 1]; U(4, a, c); try { c.call(a) } finally { U(5, a, c) } } else { U(4, o, i); try { i.call(o) } finally { U(5, o, i) } } } } } function Zg(e, t, n) { return Yg(e, t.parent, n) } function Yg(e, t, n) { let r = t; for (; r !== null && r.type & 168;)t = r, r = t.parent; if (r === null) return n[Me]; if (tn(r)) { let { encapsulation: o } = e.data[r.directiveStart + r.componentOffset]; if (o === Qe.None || o === Qe.Emulated) return null } return at(r, n) } function Kg(e, t, n) { return Xg(e, t, n) } function Jg(e, t, n) { return e.type & 40 ? at(e, n) : null } var Xg = Jg, wu; function bd(e, t, n, r) { let o = Zg(e, r, t), i = t[me], s = r.parent || t[we], a = Kg(s, r, t); if (o != null) if (Array.isArray(n)) for (let c = 0; c < n.length; c++)hu(i, o, n[c], a, !1); else hu(i, o, n, a, !1); wu !== void 0 && wu(i, r, t, n, o) } function tr(e, t) { if (t !== null) { let n = t.type; if (n & 3) return at(t, e); if (n & 4) return da(-1, e[t.index]); if (n & 8) { let r = t.child; if (r !== null) return tr(e, r); { let o = e[t.index]; return _e(o) ? da(-1, o) : Pe(o) } } else { if (n & 128) return tr(e, t.next); if (n & 32) return Ma(t, e)() || Pe(e[t.index]); { let r = Cd(e, t); if (r !== null) { if (Array.isArray(r)) return r[0]; let o = rt(e[De]); return tr(o, r) } else return tr(e, t.next) } } } return null } function Cd(e, t) { if (t !== null) { let r = e[De][we], o = t.projection; return r.projection[o] } return null } function da(e, t) { let n = de + e + 1; if (n < t.length) { let r = t[n], o = r[_].firstChild; if (o !== null) return tr(r, o) } return t[st] } function Aa(e, t, n, r, o, i, s) { for (; n != null;) { let a = r[bt]; if (n.type === 128) { n = n.next; continue } let c = r[n.index], l = n.type; if (s && t === 0 && (c && or(Pe(c), r), n.flags |= 2), !ba(n)) if (l & 8) Aa(e, t, n.child, r, o, i, !1), rn(t, e, a, o, c, n, i, r); else if (l & 32) { let p = Ma(n, r), h; for (; h = p();)rn(t, e, a, o, h, n, i, r); rn(t, e, a, o, c, n, i, r) } else l & 16 ? em(e, t, r, n, o, i) : rn(t, e, a, o, c, n, i, r); n = s ? n.projectionNext : n.next } } function Zo(e, t, n, r, o, i) { Aa(n, r, e.firstChild, t, o, i, !1) } function em(e, t, n, r, o, i) { let s = n[De], c = s[we].projection[r.projection]; if (Array.isArray(c)) for (let l = 0; l < c.length; l++) { let p = c[l]; rn(t, e, n[bt], o, p, r, i, n) } else { let l = c, p = s[X]; Yu(r) && (l.flags |= 128), Aa(e, t, l, p, o, i, !0) } } function tm(e, t, n, r, o, i, s) { let a = r[st], c = Pe(r); a !== c && rn(t, e, n, i, a, o, s); for (let l = de; l < r.length; l++) { let p = r[l]; Zo(p[_], p, e, t, i, a) } } function Td(e, t, n, r, o) { let i = nu(), s = r & 2; try { ct(-1), s && t.length > be && Og(e, t, be, !1), U(s ? 2 : 0, o, n), n(r, o) } finally { ct(i), U(s ? 3 : 1, o, n) } } function Md(e, t, n) { im(e, t, n), (n.flags & 64) === 64 && sm(e, t, n) } function _d(e, t, n = at) { let r = t.localNames; if (r !== null) { let o = t.index + 1; for (let i = 0; i < r.length; i += 2) { let s = r[i + 1], a = s === -1 ? n(t, e) : e[s]; e[o++] = a } } } function nm(e, t, n, r) { let i = r.get(rd, nd) || n === Qe.ShadowDom, s = e.selectRootElement(t, i); return rm(s), s } function rm(e) { om(e) } var om = () => null; function im(e, t, n) { let r = n.directiveStart, o = n.directiveEnd; tn(n) && Ag(t, n, e.data[r + n.componentOffset]), e.firstCreatePass || $u(n, t); let i = n.initialInputs; for (let s = r; s < o; s++) { let a = e.data[s], c = ra(t, e, s, n); if (or(c, t), i !== null && lm(t, s - r, c, a, n, i), Tt(a)) { let l = Ge(n.index, t); l[ge] = ra(t, e, s, n) } } } function sm(e, t, n) { let r = n.directiveStart, o = n.directiveEnd, i = n.index, s = Jl(); try { ct(i); for (let a = r; a < o; a++) { let c = e.data[a], l = t[a]; bo(a), (c.hostBindings !== null || c.hostVars !== 0 || c.hostAttrs !== null) && am(c, l) } } finally { ct(-1), bo(s) } } function am(e, t) { e.hostBindings !== null && e.hostBindings(1, t) } function cm(e, t) { let n = e.directiveRegistry, r = null; if (n) for (let o = 0; o < n.length; o++) { let i = n[o]; bg(t, i.selectors, !1) && (r ??= [], Tt(i) ? r.unshift(i) : r.push(i)) } return r } function lm(e, t, n, r, o, i) { let s = i[t]; if (s !== null) for (let a = 0; a < s.length; a += 2) { let c = s[a], l = s[a + 1]; ca(r, n, c, l) } } function Nd(e, t, n, r, o) { let i = be + n, s = t[_], a = o(s, t, e, r, n); t[i] = a, Kn(e, !0); let c = e.type === 2; return c ? (ld(t[me], a, e), (Bl() === 0 || Ns(e)) && or(a, t), zl()) : or(a, t), Gs() && (!c || !ba(e)) && bd(s, t, a, e), e } function xd(e) { let t = e; return Vs() ? Ql() : (t = t.parent, Kn(t, !1)), t } function Rd(e, t, n, r, o) { let i = e.inputs?.[r], s = e.hostDirectiveInputs?.[r], a = !1; if (s) for (let c = 0; c < s.length; c += 2) { let l = s[c], p = s[c + 1], h = t.data[l]; ca(h, n[l], p, o), a = !0 } if (i) for (let c of i) { let l = n[c], p = t.data[c]; ca(p, l, r, o), a = !0 } return a } function um(e, t) { let n = Ge(t, e), r = n[_]; dm(r, n); let o = n[Me]; o !== null && n[Un] === null && (n[Un] = od(o, n[bt])), U(18), Ad(r, n, n[ge]), U(19, n[ge]) } function dm(e, t) { for (let n = t.length; n < e.blueprint.length; n++)t.push(e.blueprint[n]) } function Ad(e, t, n) { Co(t); try { let r = e.viewQuery; r !== null && aa(1, r, n); let o = e.template; o !== null && Td(e, t, o, 1, n), e.firstCreatePass && (e.firstCreatePass = !1), t[$n]?.finishViewCreation(e), e.staticContentQueries && id(e, t), e.staticViewQueries && aa(2, e.viewQuery, n); let i = e.components; i !== null && fm(t, i) } catch (r) { throw e.firstCreatePass && (e.incompleteFirstPass = !0, e.firstCreatePass = !1), r } finally { t[T] &= -5, To() } } function fm(e, t) { for (let n = 0; n < t.length; n++)um(e, t[n]) } function Du(e, t) { return !t || t.firstChild === null || Yu(e) } function sr(e, t, n, r, o = !1) { for (; n !== null;) { if (n.type === 128) { n = o ? n.projectionNext : n.next; continue } let i = t[n.index]; i !== null && r.push(Pe(i)), _e(i) && Od(i, r); let s = n.type; if (s & 8) sr(e, t, n.child, r); else if (s & 32) { let a = Ma(n, t), c; for (; c = a();)r.push(c) } else if (s & 16) { let a = Cd(t, n); if (Array.isArray(a)) r.push(...a); else { let c = rt(t[De]); sr(c[_], c, a, r, !0) } } n = o ? n.projectionNext : n.next } return r } function Od(e, t) { for (let n = de; n < e.length; n++) { let r = e[n], o = r[_].firstChild; o !== null && sr(r[_], r, o, t) } e[st] !== e[Me] && t.push(e[st]) } function kd(e) { if (e[So] !== null) { for (let t of e[So]) t.impl.addSequence(t); e[So].length = 0 } } var Pd = []; function pm(e) { return e[ve] ?? hm(e) } function hm(e) { let t = Pd.pop() ?? Object.create(mm); return t.lView = e, t } function gm(e) { e.lView[ve] !== e && (e.lView = null, Pd.push(e)) } var mm = V(y({}, bn), { consumerIsAlwaysLive: !0, kind: "template", consumerMarkedDirty: e => { Yn(e.lView) }, consumerOnSignalRead() { this.lView[ve] = this } }); function vm(e) { let t = e[ve] ?? Object.create(ym); return t.lView = e, t } var ym = V(y({}, bn), { consumerIsAlwaysLive: !0, kind: "template", consumerMarkedDirty: e => { let t = rt(e.lView); for (; t && !Ld(t[_]);)t = rt(t); t && Os(t) }, consumerOnSignalRead() { this.lView[ve] = this } }); function Ld(e) { return e.type !== 2 } function Fd(e) { if (e[zn] === null) return; let t = !0; for (; t;) { let n = !1; for (let r of e[zn]) r.dirty && (n = !0, r.zone === null || Zone.current === r.zone ? r.run() : r.zone.run(() => r.run())); t = n && !!(e[T] & 8192) } } var Em = 100; function jd(e, t = 0) { let r = e[ze].rendererFactory, o = !1; o || r.begin?.(); try { Im(e, t) } finally { o || r.end?.() } } function Im(e, t) { let n = Us(); try { $s(!0), fa(e, t); let r = 0; for (; Zn(e);) { if (r === Em) throw new E(103, !1); r++, fa(e, 1) } } finally { $s(n) } } function Sm(e, t, n, r) { if (Mt(t)) return; let o = t[T], i = !1, s = !1; Co(t); let a = !0, c = null, l = null; i || (Ld(e) ? (l = pm(t), c = Tn(l)) : Ur() === null ? (a = !1, l = vm(t), c = Tn(l)) : t[ve] && (_n(t[ve]), t[ve] = null)); try { As(t), Zl(e.bindingStartIndex), n !== null && Td(e, t, n, 2, r); let p = (o & 3) === 3; if (!i) if (p) { let g = e.preOrderCheckHooks; g !== null && _o(t, g, null) } else { let g = e.preOrderHooks; g !== null && No(t, g, 0, null), Js(t, 0) } if (s || wm(t), Fd(t), Hd(t, 0), e.contentQueries !== null && id(e, t), !i) if (p) { let g = e.contentCheckHooks; g !== null && _o(t, g) } else { let g = e.contentHooks; g !== null && No(t, g, 1), Js(t, 1) } bm(e, t); let h = e.components; h !== null && Ud(t, h, 0); let v = e.viewQuery; if (v !== null && aa(2, v, r), !i) if (p) { let g = e.viewCheckHooks; g !== null && _o(t, g) } else { let g = e.viewHooks; g !== null && No(t, g, 2), Js(t, 2) } if (e.firstUpdatePass === !0 && (e.firstUpdatePass = !1), t[Io]) { for (let g of t[Io]) g(); t[Io] = null } i || (kd(t), t[T] &= -73) } catch (p) { throw i || Yn(t), p } finally { l !== null && ($r(l, c), a && gm(l)), To() } } function Hd(e, t) { for (let n = Ju(e); n !== null; n = Xu(n))for (let r = de; r < n.length; r++) { let o = n[r]; Vd(o, t) } } function wm(e) { for (let t = Ju(e); t !== null; t = Xu(t)) { if (!(t[T] & 2)) continue; let n = t[Wn]; for (let r = 0; r < n.length; r++) { let o = n[r]; Os(o) } } } function Dm(e, t, n) { U(18); let r = Ge(t, e); Vd(r, n), U(19, r[ge]) } function Vd(e, t) { wo(e) && fa(e, t) } function fa(e, t) { let r = e[_], o = e[T], i = e[ve], s = !!(t === 0 && o & 16); if (s ||= !!(o & 64 && t === 0), s ||= !!(o & 1024), s ||= !!(i?.dirty && Mn(i)), s ||= !1, i && (i.dirty = !1), e[T] &= -9217, s) Sm(r, e, r.template, e[ge]); else if (o & 8192) { let a = x(null); try { Fd(e), Hd(e, 1); let c = r.components; c !== null && Ud(e, c, 1), kd(e) } finally { x(a) } } } function Ud(e, t, n) { for (let r = 0; r < t.length; r++)Dm(e, t[r], n) } function bm(e, t) { let n = e.hostBindingOpCodes; if (n !== null) try { for (let r = 0; r < n.length; r++) { let o = n[r]; if (o < 0) ct(~o); else { let i = o, s = n[++r], a = n[++r]; Kl(s, i); let c = t[i]; U(24, c), a(2, c), U(25, c) } } } finally { ct(-1) } } function $d(e, t) { let n = Us() ? 64 : 1088; for (e[ze].changeDetectionScheduler?.notify(t); e;) { e[T] |= n; let r = rt(e); if (nn(e) && !r) return e; e = r } return null } function Cm(e, t, n, r) { return [e, !0, 0, t, null, r, null, n, null, null] } function Tm(e, t, n, r = !0) { let o = t[_]; if (Mm(o, t, e, n), r) { let s = da(n, e), a = t[me], c = a.parentNode(e[st]); c !== null && zg(o, e[we], a, t, c, s) } let i = t[Un]; i !== null && i.firstChild !== null && (i.firstChild = null) } function pa(e, t) { if (e.length <= de) return; let n = de + t, r = e[n]; if (r) { let o = r[en]; o !== null && o !== e && Ra(o, r), t > 0 && (e[n - 1][Se] = r[Se]); let i = jn(e, de + t); Bg(r[_], r); let s = i[$n]; s !== null && s.detachView(i[_]), r[X] = null, r[Se] = null, r[T] &= -129 } return r } function Mm(e, t, n, r) { let o = de + r, i = n.length; r > 0 && (n[o - 1][Se] = t), r < i - de ? (t[Se] = n[o], Es(n, de + r, t)) : (n.push(t), t[Se] = null), t[X] = n; let s = t[en]; s !== null && n !== s && Bd(s, t); let a = t[$n]; a !== null && a.insertView(e), Do(t), t[T] |= 128 } function Bd(e, t) { let n = e[Wn], r = t[X]; if (qe(r)) e[T] |= 2; else { let o = r[X][De]; t[De] !== o && (e[T] |= 2) } n === null ? e[Wn] = [t] : n.push(t) } var xt = class { _lView; _cdRefInjectingView; _appRef = null; _attachedToViewContainer = !1; exhaustive; get rootNodes() { let t = this._lView, n = t[_]; return sr(n, t, n.firstChild, []) } constructor(t, n) { this._lView = t, this._cdRefInjectingView = n } get context() { return this._lView[ge] } set context(t) { this._lView[ge] = t } get destroyed() { return Mt(this._lView) } destroy() { if (this._appRef) this._appRef.detachView(this); else if (this._attachedToViewContainer) { let t = this._lView[X]; if (_e(t)) { let n = t[Gn], r = n ? n.indexOf(this) : -1; r > -1 && (pa(t, r), jn(n, r)) } this._attachedToViewContainer = !1 } Dd(this._lView[_], this._lView) } onDestroy(t) { ks(this._lView, t) } markForCheck() { $d(this._cdRefInjectingView || this._lView, 4) } detach() { this._lView[T] &= -129 } reattach() { Do(this._lView), this._lView[T] |= 128 } detectChanges() { this._lView[T] |= 1024, jd(this._lView) } checkNoChanges() { } attachToViewContainerRef() { if (this._appRef) throw new E(902, !1); this._attachedToViewContainer = !0 } detachFromAppRef() { this._appRef = null; let t = nn(this._lView), n = this._lView[en]; n !== null && !t && Ra(n, this._lView), wd(this._lView[_], this._lView) } attachToAppRef(t) { if (this._attachedToViewContainer) throw new E(902, !1); this._appRef = t; let n = nn(this._lView), r = this._lView[en]; r !== null && !n && Bd(r, this._lView), Do(this._lView) } }; function Oa(e, t, n, r, o) { let i = e.data[t]; if (i === null) i = _m(e, t, n, r, o), Yl() && (i.flags |= 32); else if (i.type & 64) { i.type = n, i.value = r, i.attrs = o; let s = Wl(); i.injectorIndex = s === null ? -1 : s.injectorIndex } return Kn(i, !0), i } function _m(e, t, n, r, o) { let i = Hs(), s = Vs(), a = s ? i : i && i.parent, c = e.data[t] = xm(e, a, n, t, r, o); return Nm(e, c, i, s), c } function Nm(e, t, n, r) { e.firstChild === null && (e.firstChild = t), n !== null && (r ? n.child == null && t.parent !== null && (n.child = t) : n.next === null && (n.next = t, t.prev = n)) } function xm(e, t, n, r, o, i) { let s = t ? t.injectorIndex : -1, a = 0; return Gl() && (a |= 128), { type: n, index: r, insertBeforeIndex: null, injectorIndex: s, directiveStart: -1, directiveEnd: -1, directiveStylingLast: -1, componentOffset: -1, propertyBindings: null, flags: a, providerIndexes: 0, value: o, attrs: i, mergedAttrs: null, localNames: null, initialInputs: null, inputs: null, hostDirectiveInputs: null, outputs: null, hostDirectiveOutputs: null, directiveToIndex: null, tView: null, next: null, prev: null, projectionNext: null, child: null, parent: t, projection: null, styles: null, stylesWithoutHost: null, residualStyles: void 0, classes: null, classesWithoutHost: null, residualClasses: void 0, classBindings: 0, styleBindings: 0 } } var bM = new RegExp(`^(\\d+)*(${pg}|${fg})*(.*)`); var Rm = () => null; function bu(e, t) { return Rm(e, t) } var zd = class { }, Yo = class { }, ha = class { resolveComponentFactory(t) { throw new E(917, !1) } }, ur = class { static NULL = new ha }, Rt = class { }; var qd = (() => { class e { static \u0275prov = S({ token: e, providedIn: "root", factory: () => null }) } return e })(); var xo = {}, ga = class { injector; parentInjector; constructor(t, n) { this.injector = t, this.parentInjector = n } get(t, n, r) { let o = this.injector.get(t, xo, r); return o !== xo || n === xo ? o : this.parentInjector.get(t, n, r) } }; function Lo(e, t, n) { let r = n ? e.styles : null, o = n ? e.classes : null, i = 0; if (t !== null) for (let s = 0; s < t.length; s++) { let a = t[s]; if (typeof a == "number") i = a; else if (i == 1) o = ls(o, a); else if (i == 2) { let c = a, l = t[++s]; r = ls(r, c + ": " + l + ";") } } n ? e.styles = r : e.stylesWithoutHost = r, n ? e.classes = o : e.classesWithoutHost = o } function Gd(e, t = 0) { let n = ye(); if (n === null) return M(e, t); let r = Le(); return Gu(r, n, ue(e), t) } function Am(e, t, n, r, o) { let i = r === null ? null : { "": -1 }, s = o(e, n); if (s !== null) { let a = s, c = null, l = null; for (let p of s) if (p.resolveHostDirectives !== null) { [a, c, l] = p.resolveHostDirectives(s); break } Pm(e, t, n, a, i, c, l) } i !== null && r !== null && Om(n, r, i) } function Om(e, t, n) { let r = e.localNames = []; for (let o = 0; o < t.length; o += 2) { let i = n[t[o + 1]]; if (i == null) throw new E(-301, !1); r.push(t[o], i) } } function km(e, t, n) { t.componentOffset = n, (e.components ??= []).push(t.index) } function Pm(e, t, n, r, o, i, s) { let a = r.length, c = !1; for (let v = 0; v < a; v++) { let g = r[v]; !c && Tt(g) && (c = !0, km(e, n, v)), tg($u(n, t), e, g.type) } Um(n, e.data.length, a); for (let v = 0; v < a; v++) { let g = r[v]; g.providersResolver && g.providersResolver(g) } let l = !1, p = !1, h = gd(e, t, a, null); a > 0 && (n.directiveToIndex = new Map); for (let v = 0; v < a; v++) { let g = r[v]; if (n.mergedAttrs = Ea(n.mergedAttrs, g.hostAttrs), Fm(e, n, t, h, g), Vm(h, g, o), s !== null && s.has(g)) { let [N, H] = s.get(g); n.directiveToIndex.set(g.type, [h, N + n.directiveStart, H + n.directiveStart]) } else (i === null || !i.has(g)) && n.directiveToIndex.set(g.type, h); g.contentQueries !== null && (n.flags |= 4), (g.hostBindings !== null || g.hostAttrs !== null || g.hostVars !== 0) && (n.flags |= 64); let w = g.type.prototype; !l && (w.ngOnChanges || w.ngOnInit || w.ngDoCheck) && ((e.preOrderHooks ??= []).push(n.index), l = !0), !p && (w.ngOnChanges || w.ngDoCheck) && ((e.preOrderCheckHooks ??= []).push(n.index), p = !0), h++ } Lm(e, n, i) } function Lm(e, t, n) { for (let r = t.directiveStart; r < t.directiveEnd; r++) { let o = e.data[r]; if (n === null || !n.has(o)) Cu(0, t, o, r), Cu(1, t, o, r), Mu(t, r, !1); else { let i = n.get(o); Tu(0, t, i, r), Tu(1, t, i, r), Mu(t, r, !0) } } } function Cu(e, t, n, r) { let o = e === 0 ? n.inputs : n.outputs; for (let i in o) if (o.hasOwnProperty(i)) { let s; e === 0 ? s = t.inputs ??= {} : s = t.outputs ??= {}, s[i] ??= [], s[i].push(r), Wd(t, i) } } function Tu(e, t, n, r) { let o = e === 0 ? n.inputs : n.outputs; for (let i in o) if (o.hasOwnProperty(i)) { let s = o[i], a; e === 0 ? a = t.hostDirectiveInputs ??= {} : a = t.hostDirectiveOutputs ??= {}, a[s] ??= [], a[s].push(r, i), Wd(t, s) } } function Wd(e, t) { t === "class" ? e.flags |= 8 : t === "style" && (e.flags |= 16) } function Mu(e, t, n) { let { attrs: r, inputs: o, hostDirectiveInputs: i } = e; if (r === null || !n && o === null || n && i === null || Ca(e)) { e.initialInputs ??= [], e.initialInputs.push(null); return } let s = null, a = 0; for (; a < r.length;) { let c = r[a]; if (c === 0) { a += 4; continue } else if (c === 5) { a += 2; continue } else if (typeof c == "number") break; if (!n && o.hasOwnProperty(c)) { let l = o[c]; for (let p of l) if (p === t) { s ??= [], s.push(c, r[a + 1]); break } } else if (n && i.hasOwnProperty(c)) { let l = i[c]; for (let p = 0; p < l.length; p += 2)if (l[p] === t) { s ??= [], s.push(l[p + 1], r[a + 1]); break } } a += 2 } e.initialInputs ??= [], e.initialInputs.push(s) } function Fm(e, t, n, r, o) { e.data[r] = o; let i = o.factory || (o.factory = yt(o.type, !0)), s = new rr(i, Tt(o), Gd, null); e.blueprint[r] = s, n[r] = s, jm(e, t, r, gd(e, n, o.hostVars, Ta), o) } function jm(e, t, n, r, o) { let i = o.hostBindings; if (i) { let s = e.hostBindingOpCodes; s === null && (s = e.hostBindingOpCodes = []); let a = ~t.index; Hm(s) != a && s.push(a), s.push(n, r, i) } } function Hm(e) { let t = e.length; for (; t > 0;) { let n = e[--t]; if (typeof n == "number" && n < 0) return n } return 0 } function Vm(e, t, n) { if (n) { if (t.exportAs) for (let r = 0; r < t.exportAs.length; r++)n[t.exportAs[r]] = e; Tt(t) && (n[""] = e) } } function Um(e, t, n) { e.flags |= 1, e.directiveStart = t, e.directiveEnd = t + n, e.providerIndexes = t } function Qd(e, t, n, r, o, i, s, a) { let c = t[_], l = c.consts, p = Qn(l, s), h = Oa(c, e, n, r, p); return i && Am(c, t, h, Qn(l, a), o), h.mergedAttrs = Ea(h.mergedAttrs, h.attrs), h.attrs !== null && Lo(h, h.attrs, !1), h.mergedAttrs !== null && Lo(h, h.mergedAttrs, !0), c.queries !== null && c.queries.elementStart(c, h), h } function Zd(e, t) { zh(e, t), _s(t) && e.queries.elementEnd(t) } function $m(e, t, n, r, o, i) { let s = t.consts, a = Qn(s, o), c = Oa(t, e, n, r, a); if (c.mergedAttrs = Ea(c.mergedAttrs, c.attrs), i != null) { let l = Qn(s, i); c.localNames = []; for (let p = 0; p < l.length; p += 2)c.localNames.push(l[p], -1) } return c.attrs !== null && Lo(c, c.attrs, !1), c.mergedAttrs !== null && Lo(c, c.mergedAttrs, !0), t.queries !== null && t.queries.elementStart(t, c), c } var ma = Symbol("BINDING"); var Fo = class extends ur { ngModule; constructor(t) { super(), this.ngModule = t } resolveComponentFactory(t) { let n = it(t); return new an(n, this.ngModule) } }; function Bm(e) { return Object.keys(e).map(t => { let [n, r, o] = e[t], i = { propName: n, templateName: t, isSignal: (r & Wo.SignalBased) !== 0 }; return o && (i.transform = o), i }) } function zm(e) { return Object.keys(e).map(t => ({ propName: e[t], templateName: t })) } function qm(e, t, n) { let r = t instanceof J ? t : t?.injector; return r && e.getStandaloneInjector !== null && (r = e.getStandaloneInjector(r) || r), r ? new ga(n, r) : n } function Gm(e) { let t = e.get(Rt, null); if (t === null) throw new E(407, !1); let n = e.get(qd, null), r = e.get(ot, null); return { rendererFactory: t, sanitizer: n, changeDetectionScheduler: r, ngReflect: !1 } } function Wm(e, t) { let n = Yd(e); return ad(t, n, n === "svg" ? xs : n === "math" ? Vl : null) } function Yd(e) { return (e.selectors[0][0] || "div").toLowerCase() } var an = class extends Yo { componentDef; ngModule; selector; componentType; ngContentSelectors; isBoundToModule; cachedInputs = null; cachedOutputs = null; get inputs() { return this.cachedInputs ??= Bm(this.componentDef.inputs), this.cachedInputs } get outputs() { return this.cachedOutputs ??= zm(this.componentDef.outputs), this.cachedOutputs } constructor(t, n) { super(), this.componentDef = t, this.ngModule = n, this.componentType = t.type, this.selector = _g(t.selectors), this.ngContentSelectors = t.ngContentSelectors ?? [], this.isBoundToModule = !!n } create(t, n, r, o, i, s) { U(22); let a = x(null); try { let c = this.componentDef, l = Qm(r, c, s, i), p = qm(c, o || this.ngModule, t), h = Gm(p), v = h.rendererFactory.createRenderer(null, c), g = r ? nm(v, r, c.encapsulation, p) : Wm(c, v), w = s?.some(_u) || i?.some(j => typeof j != "function" && j.bindings.some(_u)), N = pd(null, l, null, 512 | hd(c), null, null, h, v, p, null, od(g, p, !0)); N[be] = g, Co(N); let H = null; try { let j = Qd(be, N, 2, "#host", () => l.directiveRegistry, !0, 0); ld(v, g, j), or(g, N), Md(l, N, j), sd(l, j, N), Zd(l, j), n !== void 0 && Ym(j, this.ngContentSelectors, n), H = Ge(j.index, N), N[ge] = H[ge], Ad(l, N, null) } catch (j) { throw H !== null && ia(H), ia(N), j } finally { U(23), To() } return new jo(this.componentType, N, !!w) } finally { x(a) } } }; function Qm(e, t, n, r) { let o = e ? ["ng-version", "20.3.16"] : Ng(t.selectors[0]), i = null, s = null, a = 0; if (n) for (let p of n) a += p[ma].requiredVars, p.create && (p.targetIdx = 0, (i ??= []).push(p)), p.update && (p.targetIdx = 0, (s ??= []).push(p)); if (r) for (let p = 0; p < r.length; p++) { let h = r[p]; if (typeof h != "function") for (let v of h.bindings) { a += v[ma].requiredVars; let g = p + 1; v.create && (v.targetIdx = g, (i ??= []).push(v)), v.update && (v.targetIdx = g, (s ??= []).push(v)) } } let c = [t]; if (r) for (let p of r) { let h = typeof p == "function" ? p : p.type, v = Ds(h); c.push(v) } return fd(0, null, Zm(i, s), 1, a, c, null, null, null, [o], null) } function Zm(e, t) { return !e && !t ? null : n => { if (n & 1 && e) for (let r of e) r.create(); if (n & 2 && t) for (let r of t) r.update() } } function _u(e) { let t = e[ma].kind; return t === "input" || t === "twoWay" } var jo = class extends zd { _rootLView; _hasInputBindings; instance; hostView; changeDetectorRef; componentType; location; previousInputValues = null; _tNode; constructor(t, n, r) { super(), this._rootLView = n, this._hasInputBindings = r, this._tNode = Rs(n[_], be), this.location = Sa(this._tNode, n), this.instance = Ge(this._tNode.index, n)[ge], this.hostView = this.changeDetectorRef = new xt(n, void 0), this.componentType = t } setInput(t, n) { this._hasInputBindings; let r = this._tNode; if (this.previousInputValues ??= new Map, this.previousInputValues.has(t) && Object.is(this.previousInputValues.get(t), n)) return; let o = this._rootLView, i = Rd(r, o[_], o, t, n); this.previousInputValues.set(t, n); let s = Ge(r.index, o); $d(s, 1) } get injector() { return new Nt(this._tNode, this._rootLView) } destroy() { this.hostView.destroy() } onDestroy(t) { this.hostView.onDestroy(t) } }; function Ym(e, t, n) { let r = e.projection = []; for (let o = 0; o < t.length; o++) { let i = n[o]; r.push(i != null && i.length ? Array.from(i) : null) } } var Ko = (() => { class e { static __NG_ELEMENT_ID__ = Km } return e })(); function Km() { let e = Le(); return Xm(e, ye()) } var Jm = Ko, Kd = class extends Jm { _lContainer; _hostTNode; _hostLView; constructor(t, n, r) { super(), this._lContainer = t, this._hostTNode = n, this._hostLView = r } get element() { return Sa(this._hostTNode, this._hostLView) } get injector() { return new Nt(this._hostTNode, this._hostLView) } get parentInjector() { let t = Ia(this._hostTNode, this._hostLView); if (Hu(t)) { let n = Oo(t, this._hostLView), r = Ao(t), o = n[_].data[r + 8]; return new Nt(o, n) } else return new Nt(null, this._hostLView) } clear() { for (; this.length > 0;)this.remove(this.length - 1) } get(t) { let n = Nu(this._lContainer); return n !== null && n[t] || null } get length() { return this._lContainer.length - de } createEmbeddedView(t, n, r) { let o, i; typeof r == "number" ? o = r : r != null && (o = r.index, i = r.injector); let s = bu(this._lContainer, t.ssrId), a = t.createEmbeddedViewImpl(n || {}, i, s); return this.insertImpl(a, o, Du(this._hostTNode, s)), a } createComponent(t, n, r, o, i, s, a) { let c = t && !Hh(t), l; if (c) l = n; else { let H = n || {}; l = H.index, r = H.injector, o = H.projectableNodes, i = H.environmentInjector || H.ngModuleRef, s = H.directives, a = H.bindings } let p = c ? t : new an(it(t)), h = r || this.parentInjector; if (!i && p.ngModule == null) { let j = (c ? h : this.parentInjector).get(J, null); j && (i = j) } let v = it(p.componentType ?? {}), g = bu(this._lContainer, v?.id ?? null), w = g?.firstChild ?? null, N = p.create(h, o, w, i, s, a); return this.insertImpl(N.hostView, l, Du(this._hostTNode, g)), N } insert(t, n) { return this.insertImpl(t, n, !0) } insertImpl(t, n, r) { let o = t._lView; if (Ul(o)) { let a = this.indexOf(t); if (a !== -1) this.detach(a); else { let c = o[X], l = new Kd(c, c[we], c[X]); l.detach(l.indexOf(t)) } } let i = this._adjustIndex(n), s = this._lContainer; return Tm(s, o, i, r), t.attachToViewContainerRef(), Es(ta(s), i, t), t } move(t, n) { return this.insert(t, n) } indexOf(t) { let n = Nu(this._lContainer); return n !== null ? n.indexOf(t) : -1 } remove(t) { let n = this._adjustIndex(t, -1), r = pa(this._lContainer, n); r && (jn(ta(this._lContainer), n), Dd(r[_], r)) } detach(t) { let n = this._adjustIndex(t, -1), r = pa(this._lContainer, n); return r && jn(ta(this._lContainer), n) != null ? new xt(r) : null } _adjustIndex(t, n = 0) { return t ?? this.length + n } }; function Nu(e) { return e[Gn] } function ta(e) { return e[Gn] || (e[Gn] = []) } function Xm(e, t) { let n, r = t[e.index]; return _e(r) ? n = r : (n = Cm(r, t, null, e), t[e.index] = n, md(t, n)), tv(n, t, e, r), new Kd(n, e, t) } function ev(e, t) { let n = e[me], r = n.createComment(""), o = at(t, e), i = n.parentNode(o); return ko(n, i, r, n.nextSibling(o), !1), r } var tv = nv; function nv(e, t, n, r) { if (e[st]) return; let o; n.type & 8 ? o = Pe(r) : o = ev(t, n), e[st] = o } var cn = class { }, Jo = class { }; var Ho = class extends cn { ngModuleType; _parent; _bootstrapComponents = []; _r3Injector; instance; destroyCbs = []; componentFactoryResolver = new Fo(this); constructor(t, n, r, o = !0) { super(), this.ngModuleType = t, this._parent = n; let i = ws(t); this._bootstrapComponents = ud(i.bootstrap), this._r3Injector = Qs(t, n, [{ provide: cn, useValue: this }, { provide: ur, useValue: this.componentFactoryResolver }, ...r], nt(t), new Set(["environment"])), o && this.resolveInjectorInitializers() } resolveInjectorInitializers() { this._r3Injector.resolveInjectorInitializers(), this.instance = this._r3Injector.get(this.ngModuleType) } get injector() { return this._r3Injector } destroy() { let t = this._r3Injector; !t.destroyed && t.destroy(), this.destroyCbs.forEach(n => n()), this.destroyCbs = null } onDestroy(t) { this.destroyCbs.push(t) } }, Vo = class extends Jo { moduleType; constructor(t) { super(), this.moduleType = t } create(t) { return new Ho(this.moduleType, t, []) } }; var ar = class extends cn { injector; componentFactoryResolver = new Fo(this); instance = null; constructor(t) { super(); let n = new It([...t.providers, { provide: cn, useValue: this }, { provide: ur, useValue: this.componentFactoryResolver }], t.parent || Vn(), t.debugName, new Set(["environment"])); this.injector = n, t.runEnvironmentInitializers && n.resolveInjectorInitializers() } destroy() { this.injector.destroy() } onDestroy(t) { this.injector.onDestroy(t) } }; function dr(e, t, n = null) { return new ar({ providers: e, parent: t, debugName: n, runEnvironmentInitializers: !0 }).injector } var rv = (() => { class e { _injector; cachedInjectors = new Map; constructor(n) { this._injector = n } getOrCreateStandaloneInjector(n) { if (!n.standalone) return null; if (!this.cachedInjectors.has(n)) { let r = bs(!1, n.type), o = r.length > 0 ? dr([r], this._injector, `Standalone[${n.type.name}]`) : null; this.cachedInjectors.set(n, o) } return this.cachedInjectors.get(n) } ngOnDestroy() { try { for (let n of this.cachedInjectors.values()) n !== null && n.destroy() } finally { this.cachedInjectors.clear() } } static \u0275prov = S({ token: e, providedIn: "environment", factory: () => new e(M(J)) }) } return e })(); function fr(e) { return $o(() => { let t = Jd(e), n = V(y({}, t), { decls: e.decls, vars: e.vars, template: e.template, consts: e.consts || null, ngContentSelectors: e.ngContentSelectors, onPush: e.changeDetection === wa.OnPush, directiveDefs: null, pipeDefs: null, dependencies: t.standalone && e.dependencies || null, getStandaloneInjector: t.standalone ? o => o.get(rv).getOrCreateStandaloneInjector(n) : null, getExternalStyles: null, signals: e.signals ?? !1, data: e.data || {}, encapsulation: e.encapsulation || Qe.Emulated, styles: e.styles || Et, _: null, schemas: e.schemas || null, tView: null, id: "" }); t.standalone && Qo("NgStandalone"), Xd(n); let r = e.dependencies; return n.directiveDefs = xu(r, ov), n.pipeDefs = xu(r, Al), n.id = av(n), n }) } function ov(e) { return it(e) || Ds(e) } function iv(e, t) { if (e == null) return wt; let n = {}; for (let r in e) if (e.hasOwnProperty(r)) { let o = e[r], i, s, a, c; Array.isArray(o) ? (a = o[0], i = o[1], s = o[2] ?? i, c = o[3] || null) : (i = o, s = o, a = Wo.None, c = null), n[i] = [r, a, c], t[i] = s } return n } function sv(e) { if (e == null) return wt; let t = {}; for (let n in e) e.hasOwnProperty(n) && (t[e[n]] = n); return t } function ka(e) { return $o(() => { let t = Jd(e); return Xd(t), t }) } function Jd(e) { let t = {}; return { type: e.type, providersResolver: null, factory: null, hostBindings: e.hostBindings || null, hostVars: e.hostVars || 0, hostAttrs: e.hostAttrs || null, contentQueries: e.contentQueries || null, declaredInputs: t, inputConfig: e.inputs || wt, exportAs: e.exportAs || null, standalone: e.standalone ?? !0, signals: e.signals === !0, selectors: e.selectors || Et, viewQuery: e.viewQuery || null, features: e.features || null, setInput: null, resolveHostDirectives: null, hostDirectives: null, inputs: iv(e.inputs, t), outputs: sv(e.outputs), debugInfo: null } } function Xd(e) { e.features?.forEach(t => t(e)) } function xu(e, t) { return e ? () => { let n = typeof e == "function" ? e() : e, r = []; for (let o of n) { let i = t(o); i !== null && r.push(i) } return r } : null } function av(e) { let t = 0, n = typeof e.consts == "function" ? "" : e.consts, r = [e.selectors, e.ngContentSelectors, e.hostVars, e.hostAttrs, n, e.vars, e.decls, e.encapsulation, e.standalone, e.signals, e.exportAs, JSON.stringify(e.inputs), JSON.stringify(e.outputs), Object.getOwnPropertyNames(e.type.prototype), !!e.contentQueries, !!e.viewQuery]; for (let i of r.join("|")) t = Math.imul(31, t) + i.charCodeAt(0) << 0; return t += 2147483648, "c" + t } var Pa = (() => { class e { log(n) { console.log(n) } warn(n) { console.warn(n) } static \u0275fac = function (r) { return new (r || e) }; static \u0275prov = S({ token: e, factory: e.\u0275fac, providedIn: "platform" }) } return e })(); var La = new I(""); function pr(e) { return !!e && typeof e.then == "function" } function ef(e) { return !!e && typeof e.subscribe == "function" } var tf = new I(""); var Fa = (() => { class e { resolve; reject; initialized = !1; done = !1; donePromise = new Promise((n, r) => { this.resolve = n, this.reject = r }); appInits = m(tf, { optional: !0 }) ?? []; injector = m(Oe); constructor() { } runInitializers() { if (this.initialized) return; let n = []; for (let o of this.appInits) { let i = oe(this.injector, o); if (pr(i)) n.push(i); else if (ef(i)) { let s = new Promise((a, c) => { i.subscribe({ complete: a, error: c }) }); n.push(s) } } let r = () => { this.done = !0, this.resolve() }; Promise.all(n).then(() => { r() }).catch(o => { this.reject(o) }), n.length === 0 && r(), this.initialized = !0 } static \u0275fac = function (r) { return new (r || e) }; static \u0275prov = S({ token: e, factory: e.\u0275fac, providedIn: "root" }) } return e })(), Xo = new I(""); function nf() { Li(() => { let e = ""; throw new E(600, e) }) } function rf(e) { return e.isBoundToModule } var cv = 10; var Ot = (() => { class e { _runningTick = !1; _destroyed = !1; _destroyListeners = []; _views = []; internalErrorHandler = m(Ne); afterRenderManager = m(Id); zonelessEnabled = m(Xn); rootEffectScheduler = m(Ks); dirtyFlags = 0; tracingSnapshot = null; allTestViews = new Set; autoDetectTestViews = new Set; includeAllTestViews = !1; afterTick = new Y; get allViews() { return [...(this.includeAllTestViews ? this.allTestViews : this.autoDetectTestViews).keys(), ...this._views] } get destroyed() { return this._destroyed } componentTypes = []; components = []; internalPendingTask = m(We); get isStable() { return this.internalPendingTask.hasPendingTasksObservable.pipe(O(n => !n)) } constructor() { m(lr, { optional: !0 }) } whenStable() { let n; return new Promise(r => { n = this.isStable.subscribe({ next: o => { o && r() } }) }).finally(() => { n.unsubscribe() }) } _injector = m(J); _rendererFactory = null; get injector() { return this._injector } bootstrap(n, r) { return this.bootstrapImpl(n, r) } bootstrapImpl(n, r, o = Oe.NULL) { return this._injector.get(G).run(() => { U(10); let s = n instanceof Yo; if (!this._injector.get(Fa).done) { let w = ""; throw new E(405, w) } let c; s ? c = n : c = this._injector.get(ur).resolveComponentFactory(n), this.componentTypes.push(c.componentType); let l = rf(c) ? void 0 : this._injector.get(cn), p = r || c.selector, h = c.create(o, [], p, l), v = h.location.nativeElement, g = h.injector.get(La, null); return g?.registerApplication(v), h.onDestroy(() => { this.detachView(h.hostView), nr(this.components, h), g?.unregisterApplication(v) }), this._loadComponent(h), U(11, h), h }) } tick() { this.zonelessEnabled || (this.dirtyFlags |= 1), this._tick() } _tick() { U(12), this.tracingSnapshot !== null ? this.tracingSnapshot.run(_a.CHANGE_DETECTION, this.tickImpl) : this.tickImpl() } tickImpl = () => { if (this._runningTick) throw new E(101, !1); let n = x(null); try { this._runningTick = !0, this.synchronize() } finally { this._runningTick = !1, this.tracingSnapshot?.dispose(), this.tracingSnapshot = null, x(n), this.afterTick.next(), U(13) } }; synchronize() { this._rendererFactory === null && !this._injector.destroyed && (this._rendererFactory = this._injector.get(Rt, null, { optional: !0 })); let n = 0; for (; this.dirtyFlags !== 0 && n++ < cv;)U(14), this.synchronizeOnce(), U(15) } synchronizeOnce() { this.dirtyFlags & 16 && (this.dirtyFlags &= -17, this.rootEffectScheduler.flush()); let n = !1; if (this.dirtyFlags & 7) { let r = !!(this.dirtyFlags & 1); this.dirtyFlags &= -8, this.dirtyFlags |= 8; for (let { _lView: o } of this.allViews) { if (!r && !Zn(o)) continue; let i = r && !this.zonelessEnabled ? 0 : 1; jd(o, i), n = !0 } if (this.dirtyFlags &= -5, this.syncDirtyFlagsWithViews(), this.dirtyFlags & 23) return } n || (this._rendererFactory?.begin?.(), this._rendererFactory?.end?.()), this.dirtyFlags & 8 && (this.dirtyFlags &= -9, this.afterRenderManager.execute()), this.syncDirtyFlagsWithViews() } syncDirtyFlagsWithViews() { if (this.allViews.some(({ _lView: n }) => Zn(n))) { this.dirtyFlags |= 2; return } else this.dirtyFlags &= -8 } attachView(n) { let r = n; this._views.push(r), r.attachToAppRef(this) } detachView(n) { let r = n; nr(this._views, r), r.detachFromAppRef() } _loadComponent(n) { this.attachView(n.hostView); try { this.tick() } catch (o) { this.internalErrorHandler(o) } this.components.push(n), this._injector.get(Xo, []).forEach(o => o(n)) } ngOnDestroy() { if (!this._destroyed) try { this._destroyListeners.forEach(n => n()), this._views.slice().forEach(n => n.destroy()) } finally { this._destroyed = !0, this._views = [], this._destroyListeners = [] } } onDestroy(n) { return this._destroyListeners.push(n), () => nr(this._destroyListeners, n) } destroy() { if (this._destroyed) throw new E(406, !1); let n = this._injector; n.destroy && !n.destroyed && n.destroy() } get viewCount() { return this._views.length } static \u0275fac = function (r) { return new (r || e) }; static \u0275prov = S({ token: e, factory: e.\u0275fac, providedIn: "root" }) } return e })(); function nr(e, t) { let n = e.indexOf(t); n > -1 && e.splice(n, 1) } var RM = typeof document < "u" && typeof document?.documentElement?.getAnimations == "function"; function Ru(e, t, n, r, o) { Rd(t, e, n, o ? "class" : "style", r) } function ja(e, t, n, r) { let o = ye(), i = o[_], s = e + be, a = i.firstCreatePass ? Qd(s, o, 2, t, cm, ql(), n, r) : i.data[s]; if (Nd(a, o, e, t, of), Ns(a)) { let c = o[_]; Md(c, o, a), sd(c, a, o) } return r != null && _d(o, a), ja } function Ha() { let e = js(), t = Le(), n = xd(t); return e.firstCreatePass && Zd(e, n), Ls(n) && Fs(), Ps(), n.classesWithoutHost != null && Gh(n) && Ru(e, n, ye(), n.classesWithoutHost, !0), n.stylesWithoutHost != null && Wh(n) && Ru(e, n, ye(), n.stylesWithoutHost, !1), Ha } function ei(e, t, n, r) { return ja(e, t, n, r), Ha(), ei } function u(e, t, n, r) { let o = ye(), i = o[_], s = e + be, a = i.firstCreatePass ? $m(s, i, 2, t, n, r) : i.data[s]; return Nd(a, o, e, t, of), r != null && _d(o, a), u } function d() { let e = Le(), t = xd(e); return Ls(t) && Fs(), Ps(), d } function $(e, t, n, r) { return u(e, t, n, r), d(), $ } var of = (e, t, n, r, o) => (Ws(!0), ad(t[me], r, ru())); var hr = "en-US"; var lv = hr; function sf(e) { typeof e == "string" && (lv = e.toLowerCase().replace(/_/g, "-")) } function f(e, t = "") { let n = ye(), r = js(), o = e + be, i = r.firstCreatePass ? Oa(r, o, 1, t, null) : r.data[o], s = uv(r, n, i, t, e); n[o] = s, Gs() && bd(r, n, s, i), Kn(i, !1) } var uv = (e, t, n, r, o) => (Ws(!0), gg(t[me], r)); var Uo = class { ngModuleFactory; componentFactories; constructor(t, n) { this.ngModuleFactory = t, this.componentFactories = n } }, Va = (() => { class e { compileModuleSync(n) { return new Vo(n) } compileModuleAsync(n) { return Promise.resolve(this.compileModuleSync(n)) } compileModuleAndAllComponentsSync(n) { let r = this.compileModuleSync(n), o = ws(n), i = ud(o.declarations).reduce((s, a) => { let c = it(a); return c && s.push(new an(c)), s }, []); return new Uo(r, i) } compileModuleAndAllComponentsAsync(n) { return Promise.resolve(this.compileModuleAndAllComponentsSync(n)) } clearCache() { } clearCacheFor(n) { } getModuleId(n) { } static \u0275fac = function (r) { return new (r || e) }; static \u0275prov = S({ token: e, factory: e.\u0275fac, providedIn: "root" }) } return e })(); var dv = (() => { class e { zone = m(G); changeDetectionScheduler = m(ot); applicationRef = m(Ot); applicationErrorHandler = m(Ne); _onMicrotaskEmptySubscription; initialize() { this._onMicrotaskEmptySubscription || (this._onMicrotaskEmptySubscription = this.zone.onMicrotaskEmpty.subscribe({ next: () => { this.changeDetectionScheduler.runningTick || this.zone.run(() => { try { this.applicationRef.dirtyFlags |= 1, this.applicationRef._tick() } catch (n) { this.applicationErrorHandler(n) } }) } })) } ngOnDestroy() { this._onMicrotaskEmptySubscription?.unsubscribe() } static \u0275fac = function (r) { return new (r || e) }; static \u0275prov = S({ token: e, factory: e.\u0275fac, providedIn: "root" }) } return e })(); function af({ ngZoneFactory: e, ignoreChangesOutsideZone: t, scheduleInRootZone: n }) { return e ??= () => new G(V(y({}, cf()), { scheduleInRootZone: n })), [{ provide: G, useFactory: e }, { provide: Be, multi: !0, useFactory: () => { let r = m(dv, { optional: !0 }); return () => r.initialize() } }, { provide: Be, multi: !0, useFactory: () => { let r = m(fv); return () => { r.initialize() } } }, t === !0 ? { provide: Ys, useValue: !0 } : [], { provide: Mo, useValue: n ?? vd }, { provide: Ne, useFactory: () => { let r = m(G), o = m(J), i; return s => { r.runOutsideAngular(() => { o.destroyed && !i ? setTimeout(() => { throw s }) : (i ??= o.get(ke), i.handleError(s)) }) } } }] } function cf(e) { return { enableLongStackTrace: !1, shouldCoalesceEventChangeDetection: e?.eventCoalescing ?? !1, shouldCoalesceRunChangeDetection: e?.runCoalescing ?? !1 } } var fv = (() => { class e { subscription = new B; initialized = !1; zone = m(G); pendingTasks = m(We); initialize() { if (this.initialized) return; this.initialized = !0; let n = null; !this.zone.isStable && !this.zone.hasPendingMacrotasks && !this.zone.hasPendingMicrotasks && (n = this.pendingTasks.add()), this.zone.runOutsideAngular(() => { this.subscription.add(this.zone.onStable.subscribe(() => { G.assertNotInAngularZone(), queueMicrotask(() => { n !== null && !this.zone.hasPendingMacrotasks && !this.zone.hasPendingMicrotasks && (this.pendingTasks.remove(n), n = null) }) })) }), this.subscription.add(this.zone.onUnstable.subscribe(() => { G.assertInAngularZone(), n ??= this.pendingTasks.add() })) } ngOnDestroy() { this.subscription.unsubscribe() } static \u0275fac = function (r) { return new (r || e) }; static \u0275prov = S({ token: e, factory: e.\u0275fac, providedIn: "root" }) } return e })(); var Ua = (() => { class e { applicationErrorHandler = m(Ne); appRef = m(Ot); taskService = m(We); ngZone = m(G); zonelessEnabled = m(Xn); tracing = m(lr, { optional: !0 }); disableScheduling = m(Ys, { optional: !0 }) ?? !1; zoneIsDefined = typeof Zone < "u" && !!Zone.root.run; schedulerTickApplyArgs = [{ data: { __scheduler_tick__: !0 } }]; subscriptions = new B; angularZoneId = this.zoneIsDefined ? this.ngZone._inner?.get(Po) : null; scheduleInRootZone = !this.zonelessEnabled && this.zoneIsDefined && (m(Mo, { optional: !0 }) ?? !1); cancelScheduledCallback = null; useMicrotaskScheduler = !1; runningTick = !1; pendingRenderTaskId = null; constructor() { this.subscriptions.add(this.appRef.afterTick.subscribe(() => { this.runningTick || this.cleanup() })), this.subscriptions.add(this.ngZone.onUnstable.subscribe(() => { this.runningTick || this.cleanup() })), this.disableScheduling ||= !this.zonelessEnabled && (this.ngZone instanceof ir || !this.zoneIsDefined) } notify(n) { if (!this.zonelessEnabled && n === 5) return; let r = !1; switch (n) { case 0: { this.appRef.dirtyFlags |= 2; break } case 3: case 2: case 4: case 5: case 1: { this.appRef.dirtyFlags |= 4; break } case 6: { this.appRef.dirtyFlags |= 2, r = !0; break } case 12: { this.appRef.dirtyFlags |= 16, r = !0; break } case 13: { this.appRef.dirtyFlags |= 2, r = !0; break } case 11: { r = !0; break } case 9: case 8: case 7: case 10: default: this.appRef.dirtyFlags |= 8 }if (this.appRef.tracingSnapshot = this.tracing?.snapshot(this.appRef.tracingSnapshot) ?? null, !this.shouldScheduleTick(r)) return; let o = this.useMicrotaskScheduler ? vu : yd; this.pendingRenderTaskId = this.taskService.add(), this.scheduleInRootZone ? this.cancelScheduledCallback = Zone.root.run(() => o(() => this.tick())) : this.cancelScheduledCallback = this.ngZone.runOutsideAngular(() => o(() => this.tick())) } shouldScheduleTick(n) { return !(this.disableScheduling && !n || this.appRef.destroyed || this.pendingRenderTaskId !== null || this.runningTick || this.appRef._runningTick || !this.zonelessEnabled && this.zoneIsDefined && Zone.current.get(Po + this.angularZoneId)) } tick() { if (this.runningTick || this.appRef.destroyed) return; if (this.appRef.dirtyFlags === 0) { this.cleanup(); return } !this.zonelessEnabled && this.appRef.dirtyFlags & 7 && (this.appRef.dirtyFlags |= 1); let n = this.taskService.add(); try { this.ngZone.run(() => { this.runningTick = !0, this.appRef._tick() }, void 0, this.schedulerTickApplyArgs) } catch (r) { this.taskService.remove(n), this.applicationErrorHandler(r) } finally { this.cleanup() } this.useMicrotaskScheduler = !0, vu(() => { this.useMicrotaskScheduler = !1, this.taskService.remove(n) }) } ngOnDestroy() { this.subscriptions.unsubscribe(), this.cleanup() } cleanup() { if (this.runningTick = !1, this.cancelScheduledCallback?.(), this.cancelScheduledCallback = null, this.pendingRenderTaskId !== null) { let n = this.pendingRenderTaskId; this.pendingRenderTaskId = null, this.taskService.remove(n) } } static \u0275fac = function (r) { return new (r || e) }; static \u0275prov = S({ token: e, factory: e.\u0275fac, providedIn: "root" }) } return e })(); function $a() { return Qo("NgZoneless"), Dt([{ provide: ot, useExisting: Ua }, { provide: G, useClass: ir }, { provide: Xn, useValue: !0 }, { provide: Mo, useValue: !1 }, []]) } function pv() { return typeof $localize < "u" && $localize.locale || hr } var Ba = new I("", { providedIn: "root", factory: () => m(Ba, { optional: !0, skipSelf: !0 }) || pv() }); function lt(e) { return Dl(e) } var lf = class { [se]; constructor(t) { this[se] = t } destroy() { this[se].destroy() } }; var ff = Symbol("InputSignalNode#UNSET"), bv = V(y({}, Br), { transformFn: void 0, applyValueToInputSignal(e, t) { Ht(e, t) } }); function pf(e, t) { let n = Object.create(bv); n.value = e, n.transformFn = t?.transform; function r() { if (Cn(n), n.value === ff) { let o = null; throw new E(-950, o) } return n.value } return r[se] = n, r } var Cv = new I(""); Cv.__NG_ELEMENT_ID__ = e => { let t = Le(); if (t === null) throw new E(204, !1); if (t.type & 2) return t.value; if (e & 8) return null; throw new E(204, !1) }; function uf(e, t) { return pf(e, t) } function Tv(e) { return pf(ff, e) } var hf = (uf.required = Tv, uf); var za = new I(""), Mv = new I(""); function gr(e) { return !e.moduleRef } function _v(e) { let t = gr(e) ? e.r3Injector : e.moduleRef.injector, n = t.get(G); return n.run(() => { gr(e) ? e.r3Injector.resolveInjectorInitializers() : e.moduleRef.resolveInjectorInitializers(); let r = t.get(Ne), o; if (n.runOutsideAngular(() => { o = n.onError.subscribe({ next: r }) }), gr(e)) { let i = () => t.destroy(), s = e.platformInjector.get(za); s.add(i), t.onDestroy(() => { o.unsubscribe(), s.delete(i) }) } else { let i = () => e.moduleRef.destroy(), s = e.platformInjector.get(za); s.add(i), e.moduleRef.onDestroy(() => { nr(e.allPlatformModules, e.moduleRef), o.unsubscribe(), s.delete(i) }) } return xv(r, n, () => { let i = t.get(We), s = i.add(), a = t.get(Fa); return a.runInitializers(), a.donePromise.then(() => { let c = t.get(Ba, hr); if (sf(c || hr), !t.get(Mv, !0)) return gr(e) ? t.get(Ot) : (e.allPlatformModules.push(e.moduleRef), e.moduleRef); if (gr(e)) { let p = t.get(Ot); return e.rootComponent !== void 0 && p.bootstrap(e.rootComponent), p } else return Nv?.(e.moduleRef, e.allPlatformModules), e.moduleRef }).finally(() => void i.remove(s)) }) }) } var Nv; function xv(e, t, n) { try { let r = n(); return pr(r) ? r.catch(o => { throw t.runOutsideAngular(() => e(o)), o }) : r } catch (r) { throw t.runOutsideAngular(() => e(r)), r } } var ti = null; function Rv(e = [], t) { return Oe.create({ name: t, providers: [{ provide: Hn, useValue: "platform" }, { provide: za, useValue: new Set([() => ti = null]) }, ...e] }) } function Av(e = []) { if (ti) return ti; let t = Rv(e); return ti = t, nf(), Ov(t), t } function Ov(e) { let t = e.get(qo, null); oe(e, () => { t?.forEach(n => n()) }) } var gf = (() => { class e { static __NG_ELEMENT_ID__ = kv } return e })(); function kv(e) { return Pv(Le(), ye(), (e & 16) === 16) } function Pv(e, t, n) { if (tn(e) && !n) { let r = Ge(e.index, t); return new xt(r, r) } else if (e.type & 175) { let r = t[De]; return new xt(r, t) } return null } function mf(e) { let { rootComponent: t, appProviders: n, platformProviders: r, platformRef: o } = e; U(8); try { let i = o?.injector ?? Av(r), s = [af({}), { provide: ot, useExisting: Ua }, iu, ...n || []], a = new ar({ providers: s, parent: i, debugName: "", runEnvironmentInitializers: !1 }); return _v({ r3Injector: a.injector, platformInjector: i, rootComponent: t }) } catch (i) { return Promise.reject(i) } finally { U(9) } } var Ef = null; function Ze() { return Ef } function qa(e) { Ef ??= e } var mr = class { }, Ga = (() => { class e { historyGo(n) { throw new Error("") } static \u0275fac = function (r) { return new (r || e) }; static \u0275prov = S({ token: e, factory: () => m(If), providedIn: "platform" }) } return e })(); var If = (() => { class e extends Ga { _location; _history; _doc = m(Z); constructor() { super(), this._location = window.location, this._history = window.history } getBaseHrefFromDOM() { return Ze().getBaseHref(this._doc) } onPopState(n) { let r = Ze().getGlobalEventTarget(this._doc, "window"); return r.addEventListener("popstate", n, !1), () => r.removeEventListener("popstate", n) } onHashChange(n) { let r = Ze().getGlobalEventTarget(this._doc, "window"); return r.addEventListener("hashchange", n, !1), () => r.removeEventListener("hashchange", n) } get href() { return this._location.href } get protocol() { return this._location.protocol } get hostname() { return this._location.hostname } get port() { return this._location.port } get pathname() { return this._location.pathname } get search() { return this._location.search } get hash() { return this._location.hash } set pathname(n) { this._location.pathname = n } pushState(n, r, o) { this._history.pushState(n, r, o) } replaceState(n, r, o) { this._history.replaceState(n, r, o) } forward() { this._history.forward() } back() { this._history.back() } historyGo(n = 0) { this._history.go(n) } getState() { return this._history.state } static \u0275fac = function (r) { return new (r || e) }; static \u0275prov = S({ token: e, factory: () => new e, providedIn: "platform" }) } return e })(); function Sf(e, t) { return e ? t ? e.endsWith("/") ? t.startsWith("/") ? e + t.slice(1) : e + t : t.startsWith("/") ? e + t : `${e}/${t}` : e : t } function vf(e) { let t = e.search(/#|\?|$/); return e[t - 1] === "/" ? e.slice(0, t - 1) + e.slice(t) : e } function ut(e) { return e && e[0] !== "?" ? `?${e}` : e } var ni = (() => { class e { historyGo(n) { throw new Error("") } static \u0275fac = function (r) { return new (r || e) }; static \u0275prov = S({ token: e, factory: () => m(Df), providedIn: "root" }) } return e })(), wf = new I(""), Df = (() => { class e extends ni { _platformLocation; _baseHref; _removeListenerFns = []; constructor(n, r) { super(), this._platformLocation = n, this._baseHref = r ?? this._platformLocation.getBaseHrefFromDOM() ?? m(Z).location?.origin ?? "" } ngOnDestroy() { for (; this._removeListenerFns.length;)this._removeListenerFns.pop()() } onPopState(n) { this._removeListenerFns.push(this._platformLocation.onPopState(n), this._platformLocation.onHashChange(n)) } getBaseHref() { return this._baseHref } prepareExternalUrl(n) { return Sf(this._baseHref, n) } path(n = !1) { let r = this._platformLocation.pathname + ut(this._platformLocation.search), o = this._platformLocation.hash; return o && n ? `${r}${o}` : r } pushState(n, r, o, i) { let s = this.prepareExternalUrl(o + ut(i)); this._platformLocation.pushState(n, r, s) } replaceState(n, r, o, i) { let s = this.prepareExternalUrl(o + ut(i)); this._platformLocation.replaceState(n, r, s) } forward() { this._platformLocation.forward() } back() { this._platformLocation.back() } getState() { return this._platformLocation.getState() } historyGo(n = 0) { this._platformLocation.historyGo?.(n) } static \u0275fac = function (r) { return new (r || e)(M(Ga), M(wf, 8)) }; static \u0275prov = S({ token: e, factory: e.\u0275fac, providedIn: "root" }) } return e })(), un = (() => { class e { _subject = new Y; _basePath; _locationStrategy; _urlChangeListeners = []; _urlChangeSubscription = null; constructor(n) { this._locationStrategy = n; let r = this._locationStrategy.getBaseHref(); this._basePath = jv(vf(yf(r))), this._locationStrategy.onPopState(o => { this._subject.next({ url: this.path(!0), pop: !0, state: o.state, type: o.type }) }) } ngOnDestroy() { this._urlChangeSubscription?.unsubscribe(), this._urlChangeListeners = [] } path(n = !1) { return this.normalize(this._locationStrategy.path(n)) } getState() { return this._locationStrategy.getState() } isCurrentPathEqualTo(n, r = "") { return this.path() == this.normalize(n + ut(r)) } normalize(n) { return e.stripTrailingSlash(Fv(this._basePath, yf(n))) } prepareExternalUrl(n) { return n && n[0] !== "/" && (n = "/" + n), this._locationStrategy.prepareExternalUrl(n) } go(n, r = "", o = null) { this._locationStrategy.pushState(o, "", n, r), this._notifyUrlChangeListeners(this.prepareExternalUrl(n + ut(r)), o) } replaceState(n, r = "", o = null) { this._locationStrategy.replaceState(o, "", n, r), this._notifyUrlChangeListeners(this.prepareExternalUrl(n + ut(r)), o) } forward() { this._locationStrategy.forward() } back() { this._locationStrategy.back() } historyGo(n = 0) { this._locationStrategy.historyGo?.(n) } onUrlChange(n) { return this._urlChangeListeners.push(n), this._urlChangeSubscription ??= this.subscribe(r => { this._notifyUrlChangeListeners(r.url, r.state) }), () => { let r = this._urlChangeListeners.indexOf(n); this._urlChangeListeners.splice(r, 1), this._urlChangeListeners.length === 0 && (this._urlChangeSubscription?.unsubscribe(), this._urlChangeSubscription = null) } } _notifyUrlChangeListeners(n = "", r) { this._urlChangeListeners.forEach(o => o(n, r)) } subscribe(n, r, o) { return this._subject.subscribe({ next: n, error: r ?? void 0, complete: o ?? void 0 }) } static normalizeQueryParams = ut; static joinWithSlash = Sf; static stripTrailingSlash = vf; static \u0275fac = function (r) { return new (r || e)(M(ni)) }; static \u0275prov = S({ token: e, factory: () => Lv(), providedIn: "root" }) } return e })(); function Lv() { return new un(M(ni)) } function Fv(e, t) { if (!e || !t.startsWith(e)) return t; let n = t.substring(e.length); return n === "" || ["/", ";", "?", "#"].includes(n[0]) ? n : t } function yf(e) { return e.replace(/\/index.html$/, "") } function jv(e) { if (new RegExp("^(https?:)?//").test(e)) { let [, n] = e.split(/\/\/[^\/]+/); return n } return e } function Wa(e, t) { t = encodeURIComponent(t); for (let n of e.split(";")) { let r = n.indexOf("="), [o, i] = r == -1 ? [n, ""] : [n.slice(0, r), n.slice(r + 1)]; if (o.trim() === t) return decodeURIComponent(i) } return null } var vr = class { }; var bf = "browser"; var yr = class { _doc; constructor(t) { this._doc = t } manager }, ri = (() => { class e extends yr { constructor(n) { super(n) } supports(n) { return !0 } addEventListener(n, r, o, i) { return n.addEventListener(r, o, i), () => this.removeEventListener(n, r, o, i) } removeEventListener(n, r, o, i) { return n.removeEventListener(r, o, i) } static \u0275fac = function (r) { return new (r || e)(M(Z)) }; static \u0275prov = S({ token: e, factory: e.\u0275fac }) } return e })(), ii = new I(""), Ja = (() => { class e { _zone; _plugins; _eventNameToPlugin = new Map; constructor(n, r) { this._zone = r, n.forEach(s => { s.manager = this }); let o = n.filter(s => !(s instanceof ri)); this._plugins = o.slice().reverse(); let i = n.find(s => s instanceof ri); i && this._plugins.push(i) } addEventListener(n, r, o, i) { return this._findPluginFor(r).addEventListener(n, r, o, i) } getZone() { return this._zone } _findPluginFor(n) { let r = this._eventNameToPlugin.get(n); if (r) return r; if (r = this._plugins.find(i => i.supports(n)), !r) throw new E(5101, !1); return this._eventNameToPlugin.set(n, r), r } static \u0275fac = function (r) { return new (r || e)(M(ii), M(G)) }; static \u0275prov = S({ token: e, factory: e.\u0275fac }) } return e })(), Qa = "ng-app-id"; function Cf(e) { for (let t of e) t.remove() } function Tf(e, t) { let n = t.createElement("style"); return n.textContent = e, n } function Hv(e, t, n, r) { let o = e.head?.querySelectorAll(`style[${Qa}="${t}"],link[${Qa}="${t}"]`); if (o) for (let i of o) i.removeAttribute(Qa), i instanceof HTMLLinkElement ? r.set(i.href.slice(i.href.lastIndexOf("/") + 1), { usage: 0, elements: [i] }) : i.textContent && n.set(i.textContent, { usage: 0, elements: [i] }) } function Ya(e, t) { let n = t.createElement("link"); return n.setAttribute("rel", "stylesheet"), n.setAttribute("href", e), n } var Xa = (() => { class e { doc; appId; nonce; inline = new Map; external = new Map; hosts = new Set; constructor(n, r, o, i = {}) { this.doc = n, this.appId = r, this.nonce = o, Hv(n, r, this.inline, this.external), this.hosts.add(n.head) } addStyles(n, r) { for (let o of n) this.addUsage(o, this.inline, Tf); r?.forEach(o => this.addUsage(o, this.external, Ya)) } removeStyles(n, r) { for (let o of n) this.removeUsage(o, this.inline); r?.forEach(o => this.removeUsage(o, this.external)) } addUsage(n, r, o) { let i = r.get(n); i ? i.usage++ : r.set(n, { usage: 1, elements: [...this.hosts].map(s => this.addElement(s, o(n, this.doc))) }) } removeUsage(n, r) { let o = r.get(n); o && (o.usage--, o.usage <= 0 && (Cf(o.elements), r.delete(n))) } ngOnDestroy() { for (let [, { elements: n }] of [...this.inline, ...this.external]) Cf(n); this.hosts.clear() } addHost(n) { this.hosts.add(n); for (let [r, { elements: o }] of this.inline) o.push(this.addElement(n, Tf(r, this.doc))); for (let [r, { elements: o }] of this.external) o.push(this.addElement(n, Ya(r, this.doc))) } removeHost(n) { this.hosts.delete(n) } addElement(n, r) { return this.nonce && r.setAttribute("nonce", this.nonce), n.appendChild(r) } static \u0275fac = function (r) { return new (r || e)(M(Z), M(zo), M(Go, 8), M(cr)) }; static \u0275prov = S({ token: e, factory: e.\u0275fac }) } return e })(), Za = { svg: "http://www.w3.org/2000/svg", xhtml: "http://www.w3.org/1999/xhtml", xlink: "http://www.w3.org/1999/xlink", xml: "http://www.w3.org/XML/1998/namespace", xmlns: "http://www.w3.org/2000/xmlns/", math: "http://www.w3.org/1998/Math/MathML" }, ec = /%COMP%/g; var _f = "%COMP%", Vv = `_nghost-${_f}`, Uv = `_ngcontent-${_f}`, $v = !0, Bv = new I("", { providedIn: "root", factory: () => $v }); function zv(e) { return Uv.replace(ec, e) } function qv(e) { return Vv.replace(ec, e) } function Nf(e, t) { return t.map(n => n.replace(ec, e)) } var tc = (() => { class e { eventManager; sharedStylesHost; appId; removeStylesOnCompDestroy; doc; ngZone; nonce; tracingService; rendererByCompId = new Map; defaultRenderer; platformIsServer; constructor(n, r, o, i, s, a, c = null, l = null) { this.eventManager = n, this.sharedStylesHost = r, this.appId = o, this.removeStylesOnCompDestroy = i, this.doc = s, this.ngZone = a, this.nonce = c, this.tracingService = l, this.platformIsServer = !1, this.defaultRenderer = new Er(n, s, a, this.platformIsServer, this.tracingService) } createRenderer(n, r) { if (!n || !r) return this.defaultRenderer; let o = this.getOrCreateRenderer(n, r); return o instanceof oi ? o.applyToHost(n) : o instanceof Ir && o.applyStyles(), o } getOrCreateRenderer(n, r) { let o = this.rendererByCompId, i = o.get(r.id); if (!i) { let s = this.doc, a = this.ngZone, c = this.eventManager, l = this.sharedStylesHost, p = this.removeStylesOnCompDestroy, h = this.platformIsServer, v = this.tracingService; switch (r.encapsulation) { case Qe.Emulated: i = new oi(c, l, r, this.appId, p, s, a, h, v); break; case Qe.ShadowDom: return new Ka(c, l, n, r, s, a, this.nonce, h, v); default: i = new Ir(c, l, r, p, s, a, h, v); break }o.set(r.id, i) } return i } ngOnDestroy() { this.rendererByCompId.clear() } componentReplaced(n) { this.rendererByCompId.delete(n) } static \u0275fac = function (r) { return new (r || e)(M(Ja), M(Xa), M(zo), M(Bv), M(Z), M(G), M(Go), M(lr, 8)) }; static \u0275prov = S({ token: e, factory: e.\u0275fac }) } return e })(), Er = class { eventManager; doc; ngZone; platformIsServer; tracingService; data = Object.create(null); throwOnSyntheticProps = !0; constructor(t, n, r, o, i) { this.eventManager = t, this.doc = n, this.ngZone = r, this.platformIsServer = o, this.tracingService = i } destroy() { } destroyNode = null; createElement(t, n) { return n ? this.doc.createElementNS(Za[n] || n, t) : this.doc.createElement(t) } createComment(t) { return this.doc.createComment(t) } createText(t) { return this.doc.createTextNode(t) } appendChild(t, n) { (Mf(t) ? t.content : t).appendChild(n) } insertBefore(t, n, r) { t && (Mf(t) ? t.content : t).insertBefore(n, r) } removeChild(t, n) { n.remove() } selectRootElement(t, n) { let r = typeof t == "string" ? this.doc.querySelector(t) : t; if (!r) throw new E(-5104, !1); return n || (r.textContent = ""), r } parentNode(t) { return t.parentNode } nextSibling(t) { return t.nextSibling } setAttribute(t, n, r, o) { if (o) { n = o + ":" + n; let i = Za[o]; i ? t.setAttributeNS(i, n, r) : t.setAttribute(n, r) } else t.setAttribute(n, r) } removeAttribute(t, n, r) { if (r) { let o = Za[r]; o ? t.removeAttributeNS(o, n) : t.removeAttribute(`${r}:${n}`) } else t.removeAttribute(n) } addClass(t, n) { t.classList.add(n) } removeClass(t, n) { t.classList.remove(n) } setStyle(t, n, r, o) { o & (At.DashCase | At.Important) ? t.style.setProperty(n, r, o & At.Important ? "important" : "") : t.style[n] = r } removeStyle(t, n, r) { r & At.DashCase ? t.style.removeProperty(n) : t.style[n] = "" } setProperty(t, n, r) { t != null && (t[n] = r) } setValue(t, n) { t.nodeValue = n } listen(t, n, r, o) { if (typeof t == "string" && (t = Ze().getGlobalEventTarget(this.doc, t), !t)) throw new E(5102, !1); let i = this.decoratePreventDefault(r); return this.tracingService?.wrapEventListener && (i = this.tracingService.wrapEventListener(t, n, i)), this.eventManager.addEventListener(t, n, i, o) } decoratePreventDefault(t) { return n => { if (n === "__ngUnwrap__") return t; t(n) === !1 && n.preventDefault() } } }; function Mf(e) { return e.tagName === "TEMPLATE" && e.content !== void 0 } var Ka = class extends Er { sharedStylesHost; hostEl; shadowRoot; constructor(t, n, r, o, i, s, a, c, l) { super(t, i, s, c, l), this.sharedStylesHost = n, this.hostEl = r, this.shadowRoot = r.attachShadow({ mode: "open" }), this.sharedStylesHost.addHost(this.shadowRoot); let p = o.styles; p = Nf(o.id, p); for (let v of p) { let g = document.createElement("style"); a && g.setAttribute("nonce", a), g.textContent = v, this.shadowRoot.appendChild(g) } let h = o.getExternalStyles?.(); if (h) for (let v of h) { let g = Ya(v, i); a && g.setAttribute("nonce", a), this.shadowRoot.appendChild(g) } } nodeOrShadowRoot(t) { return t === this.hostEl ? this.shadowRoot : t } appendChild(t, n) { return super.appendChild(this.nodeOrShadowRoot(t), n) } insertBefore(t, n, r) { return super.insertBefore(this.nodeOrShadowRoot(t), n, r) } removeChild(t, n) { return super.removeChild(null, n) } parentNode(t) { return this.nodeOrShadowRoot(super.parentNode(this.nodeOrShadowRoot(t))) } destroy() { this.sharedStylesHost.removeHost(this.shadowRoot) } }, Ir = class extends Er { sharedStylesHost; removeStylesOnCompDestroy; styles; styleUrls; constructor(t, n, r, o, i, s, a, c, l) { super(t, i, s, a, c), this.sharedStylesHost = n, this.removeStylesOnCompDestroy = o; let p = r.styles; this.styles = l ? Nf(l, p) : p, this.styleUrls = r.getExternalStyles?.(l) } applyStyles() { this.sharedStylesHost.addStyles(this.styles, this.styleUrls) } destroy() { this.removeStylesOnCompDestroy && sn.size === 0 && this.sharedStylesHost.removeStyles(this.styles, this.styleUrls) } }, oi = class extends Ir { contentAttr; hostAttr; constructor(t, n, r, o, i, s, a, c, l) { let p = o + "-" + r.id; super(t, n, r, i, s, a, c, l, p), this.contentAttr = zv(p), this.hostAttr = qv(p) } applyToHost(t) { this.applyStyles(), this.setAttribute(t, this.hostAttr, "") } createElement(t, n) { let r = super.createElement(t, n); return super.setAttribute(r, this.contentAttr, ""), r } }; var si = class e extends mr { supportsDOMEvents = !0; static makeCurrent() { qa(new e) } onAndCancel(t, n, r, o) { return t.addEventListener(n, r, o), () => { t.removeEventListener(n, r, o) } } dispatchEvent(t, n) { t.dispatchEvent(n) } remove(t) { t.remove() } createElement(t, n) { return n = n || this.getDefaultDocument(), n.createElement(t) } createHtmlDocument() { return document.implementation.createHTMLDocument("fakeTitle") } getDefaultDocument() { return document } isElementNode(t) { return t.nodeType === Node.ELEMENT_NODE } isShadowRoot(t) { return t instanceof DocumentFragment } getGlobalEventTarget(t, n) { return n === "window" ? window : n === "document" ? t : n === "body" ? t.body : null } getBaseHref(t) { let n = Gv(); return n == null ? null : Wv(n) } resetBaseElement() { Sr = null } getUserAgent() { return window.navigator.userAgent } getCookie(t) { return Wa(document.cookie, t) } }, Sr = null; function Gv() { return Sr = Sr || document.head.querySelector("base"), Sr ? Sr.getAttribute("href") : null } function Wv(e) { return new URL(e, document.baseURI).pathname } var Qv = (() => { class e { build() { return new XMLHttpRequest } static \u0275fac = function (r) { return new (r || e) }; static \u0275prov = S({ token: e, factory: e.\u0275fac }) } return e })(), xf = ["alt", "control", "meta", "shift"], Zv = { "\b": "Backspace", "	": "Tab", "\x7F": "Delete", "\x1B": "Escape", Del: "Delete", Esc: "Escape", Left: "ArrowLeft", Right: "ArrowRight", Up: "ArrowUp", Down: "ArrowDown", Menu: "ContextMenu", Scroll: "ScrollLock", Win: "OS" }, Yv = { alt: e => e.altKey, control: e => e.ctrlKey, meta: e => e.metaKey, shift: e => e.shiftKey }, Rf = (() => { class e extends yr { constructor(n) { super(n) } supports(n) { return e.parseEventName(n) != null } addEventListener(n, r, o, i) { let s = e.parseEventName(r), a = e.eventCallback(s.fullKey, o, this.manager.getZone()); return this.manager.getZone().runOutsideAngular(() => Ze().onAndCancel(n, s.domEventName, a, i)) } static parseEventName(n) { let r = n.toLowerCase().split("."), o = r.shift(); if (r.length === 0 || !(o === "keydown" || o === "keyup")) return null; let i = e._normalizeKey(r.pop()), s = "", a = r.indexOf("code"); if (a > -1 && (r.splice(a, 1), s = "code."), xf.forEach(l => { let p = r.indexOf(l); p > -1 && (r.splice(p, 1), s += l + ".") }), s += i, r.length != 0 || i.length === 0) return null; let c = {}; return c.domEventName = o, c.fullKey = s, c } static matchEventFullKeyCode(n, r) { let o = Zv[n.key] || n.key, i = ""; return r.indexOf("code.") > -1 && (o = n.code, i = "code."), o == null || !o ? !1 : (o = o.toLowerCase(), o === " " ? o = "space" : o === "." && (o = "dot"), xf.forEach(s => { if (s !== o) { let a = Yv[s]; a(n) && (i += s + ".") } }), i += o, i === r) } static eventCallback(n, r, o) { return i => { e.matchEventFullKeyCode(i, n) && o.runGuarded(() => r(i)) } } static _normalizeKey(n) { return n === "esc" ? "escape" : n } static \u0275fac = function (r) { return new (r || e)(M(Z)) }; static \u0275prov = S({ token: e, factory: e.\u0275fac }) } return e })(); function nc(e, t, n) { let r = y({ rootComponent: e, platformRef: n?.platformRef }, Kv(t)); return mf(r) } function Kv(e) { return { appProviders: [...ny, ...e?.providers ?? []], platformProviders: ty } } function Jv() { si.makeCurrent() } function Xv() { return new ke } function ey() { return Da(document), document } var ty = [{ provide: cr, useValue: bf }, { provide: qo, useValue: Jv, multi: !0 }, { provide: Z, useFactory: ey }]; var ny = [{ provide: Hn, useValue: "root" }, { provide: ke, useFactory: Xv }, { provide: ii, useClass: ri, multi: !0, deps: [Z] }, { provide: ii, useClass: Rf, multi: !0, deps: [Z] }, tc, Xa, Ja, { provide: Rt, useExisting: tc }, { provide: vr, useClass: Qv }, []]; var Af = (() => { class e { _doc; constructor(n) { this._doc = n } getTitle() { return this._doc.title } setTitle(n) { this._doc.title = n || "" } static \u0275fac = function (r) { return new (r || e)(M(Z)) }; static \u0275prov = S({ token: e, factory: e.\u0275fac, providedIn: "root" }) } return e })(); var C = "primary", kr = Symbol("RouteTitle"), ac = class { params; constructor(t) { this.params = t || {} } has(t) { return Object.prototype.hasOwnProperty.call(this.params, t) } get(t) { if (this.has(t)) { let n = this.params[t]; return Array.isArray(n) ? n[0] : n } return null } getAll(t) { if (this.has(t)) { let n = this.params[t]; return Array.isArray(n) ? n : [n] } return [] } get keys() { return Object.keys(this.params) } }; function mn(e) { return new ac(e) } function oy(e, t, n) { let r = n.path.split("/"); if (r.length > e.length || n.pathMatch === "full" && (t.hasChildren() || r.length < e.length)) return null; let o = {}; for (let i = 0; i < r.length; i++) { let s = r[i], a = e[i]; if (s[0] === ":") o[s.substring(1)] = a; else if (s !== a.path) return null } return { consumed: e.slice(0, r.length), posParams: o } } function iy(e, t) { if (e.length !== t.length) return !1; for (let n = 0; n < e.length; ++n)if (!je(e[n], t[n])) return !1; return !0 } function je(e, t) { let n = e ? cc(e) : void 0, r = t ? cc(t) : void 0; if (!n || !r || n.length != r.length) return !1; let o; for (let i = 0; i < n.length; i++)if (o = n[i], !Vf(e[o], t[o])) return !1; return !0 } function cc(e) { return [...Object.keys(e), ...Object.getOwnPropertySymbols(e)] } function Vf(e, t) { if (Array.isArray(e) && Array.isArray(t)) { if (e.length !== t.length) return !1; let n = [...e].sort(), r = [...t].sort(); return n.every((o, i) => r[i] === o) } else return e === t } function Uf(e) { return e.length > 0 ? e[e.length - 1] : null } function Je(e) { return Qi(e) ? e : pr(e) ? z(Promise.resolve(e)) : D(e) } var sy = { exact: Bf, subset: zf }, $f = { exact: ay, subset: cy, ignored: () => !0 }; function Of(e, t, n) { return sy[n.paths](e.root, t.root, n.matrixParams) && $f[n.queryParams](e.queryParams, t.queryParams) && !(n.fragment === "exact" && e.fragment !== t.fragment) } function ay(e, t) { return je(e, t) } function Bf(e, t, n) { if (!Pt(e.segments, t.segments) || !li(e.segments, t.segments, n) || e.numberOfChildren !== t.numberOfChildren) return !1; for (let r in t.children) if (!e.children[r] || !Bf(e.children[r], t.children[r], n)) return !1; return !0 } function cy(e, t) { return Object.keys(t).length <= Object.keys(e).length && Object.keys(t).every(n => Vf(e[n], t[n])) } function zf(e, t, n) { return qf(e, t, t.segments, n) } function qf(e, t, n, r) { if (e.segments.length > n.length) { let o = e.segments.slice(0, n.length); return !(!Pt(o, n) || t.hasChildren() || !li(o, n, r)) } else if (e.segments.length === n.length) { if (!Pt(e.segments, n) || !li(e.segments, n, r)) return !1; for (let o in t.children) if (!e.children[o] || !zf(e.children[o], t.children[o], r)) return !1; return !0 } else { let o = n.slice(0, e.segments.length), i = n.slice(e.segments.length); return !Pt(e.segments, o) || !li(e.segments, o, r) || !e.children[C] ? !1 : qf(e.children[C], t, i, r) } } function li(e, t, n) { return t.every((r, o) => $f[n](e[o].parameters, r.parameters)) } var Ke = class { root; queryParams; fragment; _queryParamMap; constructor(t = new F([], {}), n = {}, r = null) { this.root = t, this.queryParams = n, this.fragment = r } get queryParamMap() { return this._queryParamMap ??= mn(this.queryParams), this._queryParamMap } toString() { return dy.serialize(this) } }, F = class { segments; children; parent = null; constructor(t, n) { this.segments = t, this.children = n, Object.values(n).forEach(r => r.parent = this) } hasChildren() { return this.numberOfChildren > 0 } get numberOfChildren() { return Object.keys(this.children).length } toString() { return ui(this) } }, kt = class { path; parameters; _parameterMap; constructor(t, n) { this.path = t, this.parameters = n } get parameterMap() { return this._parameterMap ??= mn(this.parameters), this._parameterMap } toString() { return Wf(this) } }; function ly(e, t) { return Pt(e, t) && e.every((n, r) => je(n.parameters, t[r].parameters)) } function Pt(e, t) { return e.length !== t.length ? !1 : e.every((n, r) => n.path === t[r].path) } function uy(e, t) { let n = []; return Object.entries(e.children).forEach(([r, o]) => { r === C && (n = n.concat(t(o, r))) }), Object.entries(e.children).forEach(([r, o]) => { r !== C && (n = n.concat(t(o, r))) }), n } var wi = (() => { class e { static \u0275fac = function (r) { return new (r || e) }; static \u0275prov = S({ token: e, factory: () => new vn, providedIn: "root" }) } return e })(), vn = class { parse(t) { let n = new uc(t); return new Ke(n.parseRootSegment(), n.parseQueryParams(), n.parseFragment()) } serialize(t) { let n = `/${wr(t.root, !0)}`, r = hy(t.queryParams), o = typeof t.fragment == "string" ? `#${fy(t.fragment)}` : ""; return `${n}${r}${o}` } }, dy = new vn; function ui(e) { return e.segments.map(t => Wf(t)).join("/") } function wr(e, t) { if (!e.hasChildren()) return ui(e); if (t) { let n = e.children[C] ? wr(e.children[C], !1) : "", r = []; return Object.entries(e.children).forEach(([o, i]) => { o !== C && r.push(`${o}:${wr(i, !1)}`) }), r.length > 0 ? `${n}(${r.join("//")})` : n } else { let n = uy(e, (r, o) => o === C ? [wr(e.children[C], !1)] : [`${o}:${wr(r, !1)}`]); return Object.keys(e.children).length === 1 && e.children[C] != null ? `${ui(e)}/${n[0]}` : `${ui(e)}/(${n.join("//")})` } } function Gf(e) { return encodeURIComponent(e).replace(/%40/g, "@").replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",") } function ai(e) { return Gf(e).replace(/%3B/gi, ";") } function fy(e) { return encodeURI(e) } function lc(e) { return Gf(e).replace(/\(/g, "%28").replace(/\)/g, "%29").replace(/%26/gi, "&") } function di(e) { return decodeURIComponent(e) } function kf(e) { return di(e.replace(/\+/g, "%20")) } function Wf(e) { return `${lc(e.path)}${py(e.parameters)}` } function py(e) { return Object.entries(e).map(([t, n]) => `;${lc(t)}=${lc(n)}`).join("") } function hy(e) { let t = Object.entries(e).map(([n, r]) => Array.isArray(r) ? r.map(o => `${ai(n)}=${ai(o)}`).join("&") : `${ai(n)}=${ai(r)}`).filter(n => n); return t.length ? `?${t.join("&")}` : "" } var gy = /^[^\/()?;#]+/; function rc(e) { let t = e.match(gy); return t ? t[0] : "" } var my = /^[^\/()?;=#]+/; function vy(e) { let t = e.match(my); return t ? t[0] : "" } var yy = /^[^=?&#]+/; function Ey(e) { let t = e.match(yy); return t ? t[0] : "" } var Iy = /^[^&#]+/; function Sy(e) { let t = e.match(Iy); return t ? t[0] : "" } var uc = class { url; remaining; constructor(t) { this.url = t, this.remaining = t } parseRootSegment() { return this.consumeOptional("/"), this.remaining === "" || this.peekStartsWith("?") || this.peekStartsWith("#") ? new F([], {}) : new F([], this.parseChildren()) } parseQueryParams() { let t = {}; if (this.consumeOptional("?")) do this.parseQueryParam(t); while (this.consumeOptional("&")); return t } parseFragment() { return this.consumeOptional("#") ? decodeURIComponent(this.remaining) : null } parseChildren() { if (this.remaining === "") return {}; this.consumeOptional("/"); let t = []; for (this.peekStartsWith("(") || t.push(this.parseSegment()); this.peekStartsWith("/") && !this.peekStartsWith("//") && !this.peekStartsWith("/(");)this.capture("/"), t.push(this.parseSegment()); let n = {}; this.peekStartsWith("/(") && (this.capture("/"), n = this.parseParens(!0)); let r = {}; return this.peekStartsWith("(") && (r = this.parseParens(!1)), (t.length > 0 || Object.keys(n).length > 0) && (r[C] = new F(t, n)), r } parseSegment() { let t = rc(this.remaining); if (t === "" && this.peekStartsWith(";")) throw new E(4009, !1); return this.capture(t), new kt(di(t), this.parseMatrixParams()) } parseMatrixParams() { let t = {}; for (; this.consumeOptional(";");)this.parseParam(t); return t } parseParam(t) { let n = vy(this.remaining); if (!n) return; this.capture(n); let r = ""; if (this.consumeOptional("=")) { let o = rc(this.remaining); o && (r = o, this.capture(r)) } t[di(n)] = di(r) } parseQueryParam(t) { let n = Ey(this.remaining); if (!n) return; this.capture(n); let r = ""; if (this.consumeOptional("=")) { let s = Sy(this.remaining); s && (r = s, this.capture(r)) } let o = kf(n), i = kf(r); if (t.hasOwnProperty(o)) { let s = t[o]; Array.isArray(s) || (s = [s], t[o] = s), s.push(i) } else t[o] = i } parseParens(t) { let n = {}; for (this.capture("("); !this.consumeOptional(")") && this.remaining.length > 0;) { let r = rc(this.remaining), o = this.remaining[r.length]; if (o !== "/" && o !== ")" && o !== ";") throw new E(4010, !1); let i; r.indexOf(":") > -1 ? (i = r.slice(0, r.indexOf(":")), this.capture(i), this.capture(":")) : t && (i = C); let s = this.parseChildren(); n[i ?? C] = Object.keys(s).length === 1 && s[C] ? s[C] : new F([], s), this.consumeOptional("//") } return n } peekStartsWith(t) { return this.remaining.startsWith(t) } consumeOptional(t) { return this.peekStartsWith(t) ? (this.remaining = this.remaining.substring(t.length), !0) : !1 } capture(t) { if (!this.consumeOptional(t)) throw new E(4011, !1) } }; function Qf(e) { return e.segments.length > 0 ? new F([], { [C]: e }) : e } function Zf(e) { let t = {}; for (let [r, o] of Object.entries(e.children)) { let i = Zf(o); if (r === C && i.segments.length === 0 && i.hasChildren()) for (let [s, a] of Object.entries(i.children)) t[s] = a; else (i.segments.length > 0 || i.hasChildren()) && (t[r] = i) } let n = new F(e.segments, t); return wy(n) } function wy(e) { if (e.numberOfChildren === 1 && e.children[C]) { let t = e.children[C]; return new F(e.segments.concat(t.segments), t.children) } return e } function yn(e) { return e instanceof Ke } function Dy(e, t, n = null, r = null) { let o = Yf(e); return Kf(o, t, n, r) } function Yf(e) { let t; function n(i) { let s = {}; for (let c of i.children) { let l = n(c); s[c.outlet] = l } let a = new F(i.url, s); return i === e && (t = a), a } let r = n(e.root), o = Qf(r); return t ?? o } function Kf(e, t, n, r) { let o = e; for (; o.parent;)o = o.parent; if (t.length === 0) return oc(o, o, o, n, r); let i = by(t); if (i.toRoot()) return oc(o, o, new F([], {}), n, r); let s = Cy(i, o, e), a = s.processChildren ? br(s.segmentGroup, s.index, i.commands) : Xf(s.segmentGroup, s.index, i.commands); return oc(o, s.segmentGroup, a, n, r) } function fi(e) { return typeof e == "object" && e != null && !e.outlets && !e.segmentPath } function Mr(e) { return typeof e == "object" && e != null && e.outlets } function oc(e, t, n, r, o) { let i = {}; r && Object.entries(r).forEach(([c, l]) => { i[c] = Array.isArray(l) ? l.map(p => `${p}`) : `${l}` }); let s; e === t ? s = n : s = Jf(e, t, n); let a = Qf(Zf(s)); return new Ke(a, i, o) } function Jf(e, t, n) { let r = {}; return Object.entries(e.children).forEach(([o, i]) => { i === t ? r[o] = n : r[o] = Jf(i, t, n) }), new F(e.segments, r) } var pi = class { isAbsolute; numberOfDoubleDots; commands; constructor(t, n, r) { if (this.isAbsolute = t, this.numberOfDoubleDots = n, this.commands = r, t && r.length > 0 && fi(r[0])) throw new E(4003, !1); let o = r.find(Mr); if (o && o !== Uf(r)) throw new E(4004, !1) } toRoot() { return this.isAbsolute && this.commands.length === 1 && this.commands[0] == "/" } }; function by(e) { if (typeof e[0] == "string" && e.length === 1 && e[0] === "/") return new pi(!0, 0, e); let t = 0, n = !1, r = e.reduce((o, i, s) => { if (typeof i == "object" && i != null) { if (i.outlets) { let a = {}; return Object.entries(i.outlets).forEach(([c, l]) => { a[c] = typeof l == "string" ? l.split("/") : l }), [...o, { outlets: a }] } if (i.segmentPath) return [...o, i.segmentPath] } return typeof i != "string" ? [...o, i] : s === 0 ? (i.split("/").forEach((a, c) => { c == 0 && a === "." || (c == 0 && a === "" ? n = !0 : a === ".." ? t++ : a != "" && o.push(a)) }), o) : [...o, i] }, []); return new pi(n, t, r) } var pn = class { segmentGroup; processChildren; index; constructor(t, n, r) { this.segmentGroup = t, this.processChildren = n, this.index = r } }; function Cy(e, t, n) { if (e.isAbsolute) return new pn(t, !0, 0); if (!n) return new pn(t, !1, NaN); if (n.parent === null) return new pn(n, !0, 0); let r = fi(e.commands[0]) ? 0 : 1, o = n.segments.length - 1 + r; return Ty(n, o, e.numberOfDoubleDots) } function Ty(e, t, n) { let r = e, o = t, i = n; for (; i > o;) { if (i -= o, r = r.parent, !r) throw new E(4005, !1); o = r.segments.length } return new pn(r, !1, o - i) } function My(e) { return Mr(e[0]) ? e[0].outlets : { [C]: e } } function Xf(e, t, n) { if (e ??= new F([], {}), e.segments.length === 0 && e.hasChildren()) return br(e, t, n); let r = _y(e, t, n), o = n.slice(r.commandIndex); if (r.match && r.pathIndex < e.segments.length) { let i = new F(e.segments.slice(0, r.pathIndex), {}); return i.children[C] = new F(e.segments.slice(r.pathIndex), e.children), br(i, 0, o) } else return r.match && o.length === 0 ? new F(e.segments, {}) : r.match && !e.hasChildren() ? dc(e, t, n) : r.match ? br(e, 0, o) : dc(e, t, n) } function br(e, t, n) { if (n.length === 0) return new F(e.segments, {}); { let r = My(n), o = {}; if (Object.keys(r).some(i => i !== C) && e.children[C] && e.numberOfChildren === 1 && e.children[C].segments.length === 0) { let i = br(e.children[C], t, n); return new F(e.segments, i.children) } return Object.entries(r).forEach(([i, s]) => { typeof s == "string" && (s = [s]), s !== null && (o[i] = Xf(e.children[i], t, s)) }), Object.entries(e.children).forEach(([i, s]) => { r[i] === void 0 && (o[i] = s) }), new F(e.segments, o) } } function _y(e, t, n) { let r = 0, o = t, i = { match: !1, pathIndex: 0, commandIndex: 0 }; for (; o < e.segments.length;) { if (r >= n.length) return i; let s = e.segments[o], a = n[r]; if (Mr(a)) break; let c = `${a}`, l = r < n.length - 1 ? n[r + 1] : null; if (o > 0 && c === void 0) break; if (c && l && typeof l == "object" && l.outlets === void 0) { if (!Lf(c, l, s)) return i; r += 2 } else { if (!Lf(c, {}, s)) return i; r++ } o++ } return { match: !0, pathIndex: o, commandIndex: r } } function dc(e, t, n) { let r = e.segments.slice(0, t), o = 0; for (; o < n.length;) { let i = n[o]; if (Mr(i)) { let c = Ny(i.outlets); return new F(r, c) } if (o === 0 && fi(n[0])) { let c = e.segments[t]; r.push(new kt(c.path, Pf(n[0]))), o++; continue } let s = Mr(i) ? i.outlets[C] : `${i}`, a = o < n.length - 1 ? n[o + 1] : null; s && a && fi(a) ? (r.push(new kt(s, Pf(a))), o += 2) : (r.push(new kt(s, {})), o++) } return new F(r, {}) } function Ny(e) { let t = {}; return Object.entries(e).forEach(([n, r]) => { typeof r == "string" && (r = [r]), r !== null && (t[n] = dc(new F([], {}), 0, r)) }), t } function Pf(e) { let t = {}; return Object.entries(e).forEach(([n, r]) => t[n] = `${r}`), t } function Lf(e, t, n) { return e == n.path && je(t, n.parameters) } var Cr = "imperative", ne = (function (e) { return e[e.NavigationStart = 0] = "NavigationStart", e[e.NavigationEnd = 1] = "NavigationEnd", e[e.NavigationCancel = 2] = "NavigationCancel", e[e.NavigationError = 3] = "NavigationError", e[e.RoutesRecognized = 4] = "RoutesRecognized", e[e.ResolveStart = 5] = "ResolveStart", e[e.ResolveEnd = 6] = "ResolveEnd", e[e.GuardsCheckStart = 7] = "GuardsCheckStart", e[e.GuardsCheckEnd = 8] = "GuardsCheckEnd", e[e.RouteConfigLoadStart = 9] = "RouteConfigLoadStart", e[e.RouteConfigLoadEnd = 10] = "RouteConfigLoadEnd", e[e.ChildActivationStart = 11] = "ChildActivationStart", e[e.ChildActivationEnd = 12] = "ChildActivationEnd", e[e.ActivationStart = 13] = "ActivationStart", e[e.ActivationEnd = 14] = "ActivationEnd", e[e.Scroll = 15] = "Scroll", e[e.NavigationSkipped = 16] = "NavigationSkipped", e })(ne || {}), Ce = class { id; url; constructor(t, n) { this.id = t, this.url = n } }, En = class extends Ce { type = ne.NavigationStart; navigationTrigger; restoredState; constructor(t, n, r = "imperative", o = null) { super(t, n), this.navigationTrigger = r, this.restoredState = o } toString() { return `NavigationStart(id: ${this.id}, url: '${this.url}')` } }, dt = class extends Ce { urlAfterRedirects; type = ne.NavigationEnd; constructor(t, n, r) { super(t, n), this.urlAfterRedirects = r } toString() { return `NavigationEnd(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}')` } }, fe = (function (e) { return e[e.Redirect = 0] = "Redirect", e[e.SupersededByNewNavigation = 1] = "SupersededByNewNavigation", e[e.NoDataFromResolver = 2] = "NoDataFromResolver", e[e.GuardRejected = 3] = "GuardRejected", e[e.Aborted = 4] = "Aborted", e })(fe || {}), hi = (function (e) { return e[e.IgnoredSameUrlNavigation = 0] = "IgnoredSameUrlNavigation", e[e.IgnoredByUrlHandlingStrategy = 1] = "IgnoredByUrlHandlingStrategy", e })(hi || {}), Ye = class extends Ce { reason; code; type = ne.NavigationCancel; constructor(t, n, r, o) { super(t, n), this.reason = r, this.code = o } toString() { return `NavigationCancel(id: ${this.id}, url: '${this.url}')` } }, ft = class extends Ce { reason; code; type = ne.NavigationSkipped; constructor(t, n, r, o) { super(t, n), this.reason = r, this.code = o } }, _r = class extends Ce { error; target; type = ne.NavigationError; constructor(t, n, r, o) { super(t, n), this.error = r, this.target = o } toString() { return `NavigationError(id: ${this.id}, url: '${this.url}', error: ${this.error})` } }, gi = class extends Ce { urlAfterRedirects; state; type = ne.RoutesRecognized; constructor(t, n, r, o) { super(t, n), this.urlAfterRedirects = r, this.state = o } toString() { return `RoutesRecognized(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})` } }, fc = class extends Ce { urlAfterRedirects; state; type = ne.GuardsCheckStart; constructor(t, n, r, o) { super(t, n), this.urlAfterRedirects = r, this.state = o } toString() { return `GuardsCheckStart(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})` } }, pc = class extends Ce { urlAfterRedirects; state; shouldActivate; type = ne.GuardsCheckEnd; constructor(t, n, r, o, i) { super(t, n), this.urlAfterRedirects = r, this.state = o, this.shouldActivate = i } toString() { return `GuardsCheckEnd(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state}, shouldActivate: ${this.shouldActivate})` } }, hc = class extends Ce { urlAfterRedirects; state; type = ne.ResolveStart; constructor(t, n, r, o) { super(t, n), this.urlAfterRedirects = r, this.state = o } toString() { return `ResolveStart(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})` } }, gc = class extends Ce { urlAfterRedirects; state; type = ne.ResolveEnd; constructor(t, n, r, o) { super(t, n), this.urlAfterRedirects = r, this.state = o } toString() { return `ResolveEnd(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})` } }, mc = class { route; type = ne.RouteConfigLoadStart; constructor(t) { this.route = t } toString() { return `RouteConfigLoadStart(path: ${this.route.path})` } }, vc = class { route; type = ne.RouteConfigLoadEnd; constructor(t) { this.route = t } toString() { return `RouteConfigLoadEnd(path: ${this.route.path})` } }, yc = class { snapshot; type = ne.ChildActivationStart; constructor(t) { this.snapshot = t } toString() { return `ChildActivationStart(path: '${this.snapshot.routeConfig && this.snapshot.routeConfig.path || ""}')` } }, Ec = class { snapshot; type = ne.ChildActivationEnd; constructor(t) { this.snapshot = t } toString() { return `ChildActivationEnd(path: '${this.snapshot.routeConfig && this.snapshot.routeConfig.path || ""}')` } }, Ic = class { snapshot; type = ne.ActivationStart; constructor(t) { this.snapshot = t } toString() { return `ActivationStart(path: '${this.snapshot.routeConfig && this.snapshot.routeConfig.path || ""}')` } }, Sc = class { snapshot; type = ne.ActivationEnd; constructor(t) { this.snapshot = t } toString() { return `ActivationEnd(path: '${this.snapshot.routeConfig && this.snapshot.routeConfig.path || ""}')` } }; var Nr = class { }, In = class { url; navigationBehaviorOptions; constructor(t, n) { this.url = t, this.navigationBehaviorOptions = n } }; function xy(e) { return !(e instanceof Nr) && !(e instanceof In) } function Ry(e, t) { return e.providers && !e._injector && (e._injector = dr(e.providers, t, `Route: ${e.path}`)), e._injector ?? t } function Re(e) { return e.outlet || C } function Ay(e, t) { let n = e.filter(r => Re(r) === t); return n.push(...e.filter(r => Re(r) !== t)), n } function wn(e) { if (!e) return null; if (e.routeConfig?._injector) return e.routeConfig._injector; for (let t = e.parent; t; t = t.parent) { let n = t.routeConfig; if (n?._loadedInjector) return n._loadedInjector; if (n?._injector) return n._injector } return null } var wc = class { rootInjector; outlet = null; route = null; children; attachRef = null; get injector() { return wn(this.route?.snapshot) ?? this.rootInjector } constructor(t) { this.rootInjector = t, this.children = new Pr(this.rootInjector) } }, Pr = (() => { class e { rootInjector; contexts = new Map; constructor(n) { this.rootInjector = n } onChildOutletCreated(n, r) { let o = this.getOrCreateContext(n); o.outlet = r, this.contexts.set(n, o) } onChildOutletDestroyed(n) { let r = this.getContext(n); r && (r.outlet = null, r.attachRef = null) } onOutletDeactivated() { let n = this.contexts; return this.contexts = new Map, n } onOutletReAttached(n) { this.contexts = n } getOrCreateContext(n) { let r = this.getContext(n); return r || (r = new wc(this.rootInjector), this.contexts.set(n, r)), r } getContext(n) { return this.contexts.get(n) || null } static \u0275fac = function (r) { return new (r || e)(M(J)) }; static \u0275prov = S({ token: e, factory: e.\u0275fac, providedIn: "root" }) } return e })(), mi = class { _root; constructor(t) { this._root = t } get root() { return this._root.value } parent(t) { let n = this.pathFromRoot(t); return n.length > 1 ? n[n.length - 2] : null } children(t) { let n = Dc(t, this._root); return n ? n.children.map(r => r.value) : [] } firstChild(t) { let n = Dc(t, this._root); return n && n.children.length > 0 ? n.children[0].value : null } siblings(t) { let n = bc(t, this._root); return n.length < 2 ? [] : n[n.length - 2].children.map(o => o.value).filter(o => o !== t) } pathFromRoot(t) { return bc(t, this._root).map(n => n.value) } }; function Dc(e, t) { if (e === t.value) return t; for (let n of t.children) { let r = Dc(e, n); if (r) return r } return null } function bc(e, t) { if (e === t.value) return [t]; for (let n of t.children) { let r = bc(e, n); if (r.length) return r.unshift(t), r } return [] } var Ee = class { value; children; constructor(t, n) { this.value = t, this.children = n } toString() { return `TreeNode(${this.value})` } }; function fn(e) { let t = {}; return e && e.children.forEach(n => t[n.value.outlet] = n), t } var vi = class extends mi { snapshot; constructor(t, n) { super(t), this.snapshot = n, Oc(this, t) } toString() { return this.snapshot.toString() } }; function ep(e) { let t = Oy(e), n = new K([new kt("", {})]), r = new K({}), o = new K({}), i = new K({}), s = new K(""), a = new Lt(n, r, i, s, o, C, e, t.root); return a.snapshot = t.root, new vi(new Ee(a, []), t) } function Oy(e) { let t = {}, n = {}, r = {}, i = new hn([], t, r, "", n, C, e, null, {}); return new Ei("", new Ee(i, [])) } var Lt = class { urlSubject; paramsSubject; queryParamsSubject; fragmentSubject; dataSubject; outlet; component; snapshot; _futureSnapshot; _routerState; _paramMap; _queryParamMap; title; url; params; queryParams; fragment; data; constructor(t, n, r, o, i, s, a, c) { this.urlSubject = t, this.paramsSubject = n, this.queryParamsSubject = r, this.fragmentSubject = o, this.dataSubject = i, this.outlet = s, this.component = a, this._futureSnapshot = c, this.title = this.dataSubject?.pipe(O(l => l[kr])) ?? D(void 0), this.url = t, this.params = n, this.queryParams = r, this.fragment = o, this.data = i } get routeConfig() { return this._futureSnapshot.routeConfig } get root() { return this._routerState.root } get parent() { return this._routerState.parent(this) } get firstChild() { return this._routerState.firstChild(this) } get children() { return this._routerState.children(this) } get pathFromRoot() { return this._routerState.pathFromRoot(this) } get paramMap() { return this._paramMap ??= this.params.pipe(O(t => mn(t))), this._paramMap } get queryParamMap() { return this._queryParamMap ??= this.queryParams.pipe(O(t => mn(t))), this._queryParamMap } toString() { return this.snapshot ? this.snapshot.toString() : `Future(${this._futureSnapshot})` } }; function yi(e, t, n = "emptyOnly") { let r, { routeConfig: o } = e; return t !== null && (n === "always" || o?.path === "" || !t.component && !t.routeConfig?.loadComponent) ? r = { params: y(y({}, t.params), e.params), data: y(y({}, t.data), e.data), resolve: y(y(y(y({}, e.data), t.data), o?.data), e._resolvedData) } : r = { params: y({}, e.params), data: y({}, e.data), resolve: y(y({}, e.data), e._resolvedData ?? {}) }, o && np(o) && (r.resolve[kr] = o.title), r } var hn = class { url; params; queryParams; fragment; data; outlet; component; routeConfig; _resolve; _resolvedData; _routerState; _paramMap; _queryParamMap; get title() { return this.data?.[kr] } constructor(t, n, r, o, i, s, a, c, l) { this.url = t, this.params = n, this.queryParams = r, this.fragment = o, this.data = i, this.outlet = s, this.component = a, this.routeConfig = c, this._resolve = l } get root() { return this._routerState.root } get parent() { return this._routerState.parent(this) } get firstChild() { return this._routerState.firstChild(this) } get children() { return this._routerState.children(this) } get pathFromRoot() { return this._routerState.pathFromRoot(this) } get paramMap() { return this._paramMap ??= mn(this.params), this._paramMap } get queryParamMap() { return this._queryParamMap ??= mn(this.queryParams), this._queryParamMap } toString() { let t = this.url.map(r => r.toString()).join("/"), n = this.routeConfig ? this.routeConfig.path : ""; return `Route(url:'${t}', path:'${n}')` } }, Ei = class extends mi { url; constructor(t, n) { super(n), this.url = t, Oc(this, n) } toString() { return tp(this._root) } }; function Oc(e, t) { t.value._routerState = e, t.children.forEach(n => Oc(e, n)) } function tp(e) { let t = e.children.length > 0 ? ` { ${e.children.map(tp).join(", ")} } ` : ""; return `${e.value}${t}` } function ic(e) { if (e.snapshot) { let t = e.snapshot, n = e._futureSnapshot; e.snapshot = n, je(t.queryParams, n.queryParams) || e.queryParamsSubject.next(n.queryParams), t.fragment !== n.fragment && e.fragmentSubject.next(n.fragment), je(t.params, n.params) || e.paramsSubject.next(n.params), iy(t.url, n.url) || e.urlSubject.next(n.url), je(t.data, n.data) || e.dataSubject.next(n.data) } else e.snapshot = e._futureSnapshot, e.dataSubject.next(e._futureSnapshot.data) } function Cc(e, t) { let n = je(e.params, t.params) && ly(e.url, t.url), r = !e.parent != !t.parent; return n && !r && (!e.parent || Cc(e.parent, t.parent)) } function np(e) { return typeof e.title == "string" || e.title === null } var ky = new I(""), rp = (() => { class e { activated = null; get activatedComponentRef() { return this.activated } _activatedRoute = null; name = C; activateEvents = new ie; deactivateEvents = new ie; attachEvents = new ie; detachEvents = new ie; routerOutletData = hf(); parentContexts = m(Pr); location = m(Ko); changeDetector = m(gf); inputBinder = m(Di, { optional: !0 }); supportsBindingToComponentInputs = !0; ngOnChanges(n) { if (n.name) { let { firstChange: r, previousValue: o } = n.name; if (r) return; this.isTrackedInParentContexts(o) && (this.deactivate(), this.parentContexts.onChildOutletDestroyed(o)), this.initializeOutletWithName() } } ngOnDestroy() { this.isTrackedInParentContexts(this.name) && this.parentContexts.onChildOutletDestroyed(this.name), this.inputBinder?.unsubscribeFromRouteData(this) } isTrackedInParentContexts(n) { return this.parentContexts.getContext(n)?.outlet === this } ngOnInit() { this.initializeOutletWithName() } initializeOutletWithName() { if (this.parentContexts.onChildOutletCreated(this.name, this), this.activated) return; let n = this.parentContexts.getContext(this.name); n?.route && (n.attachRef ? this.attach(n.attachRef, n.route) : this.activateWith(n.route, n.injector)) } get isActivated() { return !!this.activated } get component() { if (!this.activated) throw new E(4012, !1); return this.activated.instance } get activatedRoute() { if (!this.activated) throw new E(4012, !1); return this._activatedRoute } get activatedRouteData() { return this._activatedRoute ? this._activatedRoute.snapshot.data : {} } detach() { if (!this.activated) throw new E(4012, !1); this.location.detach(); let n = this.activated; return this.activated = null, this._activatedRoute = null, this.detachEvents.emit(n.instance), n } attach(n, r) { this.activated = n, this._activatedRoute = r, this.location.insert(n.hostView), this.inputBinder?.bindActivatedRouteToOutletComponent(this), this.attachEvents.emit(n.instance) } deactivate() { if (this.activated) { let n = this.component; this.activated.destroy(), this.activated = null, this._activatedRoute = null, this.deactivateEvents.emit(n) } } activateWith(n, r) { if (this.isActivated) throw new E(4013, !1); this._activatedRoute = n; let o = this.location, s = n.snapshot.component, a = this.parentContexts.getOrCreateContext(this.name).children, c = new Tc(n, a, o.injector, this.routerOutletData); this.activated = o.createComponent(s, { index: o.length, injector: c, environmentInjector: r }), this.changeDetector.markForCheck(), this.inputBinder?.bindActivatedRouteToOutletComponent(this), this.activateEvents.emit(this.activated.instance) } static \u0275fac = function (r) { return new (r || e) }; static \u0275dir = ka({ type: e, selectors: [["router-outlet"]], inputs: { name: "name", routerOutletData: [1, "routerOutletData"] }, outputs: { activateEvents: "activate", deactivateEvents: "deactivate", attachEvents: "attach", detachEvents: "detach" }, exportAs: ["outlet"], features: [ya] }) } return e })(), Tc = class { route; childContexts; parent; outletData; constructor(t, n, r, o) { this.route = t, this.childContexts = n, this.parent = r, this.outletData = o } get(t, n) { return t === Lt ? this.route : t === Pr ? this.childContexts : t === ky ? this.outletData : this.parent.get(t, n) } }, Di = new I(""); var op = (() => { class e { static \u0275fac = function (r) { return new (r || e) }; static \u0275cmp = fr({ type: e, selectors: [["ng-component"]], exportAs: ["emptyRouterOutlet"], decls: 1, vars: 0, template: function (r, o) { r & 1 && ei(0, "router-outlet") }, dependencies: [rp], encapsulation: 2 }) } return e })(); function kc(e) { let t = e.children && e.children.map(kc), n = t ? V(y({}, e), { children: t }) : y({}, e); return !n.component && !n.loadComponent && (t || n.loadChildren) && n.outlet && n.outlet !== C && (n.component = op), n } function Py(e, t, n) { let r = xr(e, t._root, n ? n._root : void 0); return new vi(r, t) } function xr(e, t, n) { if (n && e.shouldReuseRoute(t.value, n.value.snapshot)) { let r = n.value; r._futureSnapshot = t.value; let o = Ly(e, t, n); return new Ee(r, o) } else { if (e.shouldAttach(t.value)) { let i = e.retrieve(t.value); if (i !== null) { let s = i.route; return s.value._futureSnapshot = t.value, s.children = t.children.map(a => xr(e, a)), s } } let r = Fy(t.value), o = t.children.map(i => xr(e, i)); return new Ee(r, o) } } function Ly(e, t, n) { return t.children.map(r => { for (let o of n.children) if (e.shouldReuseRoute(r.value, o.value.snapshot)) return xr(e, r, o); return xr(e, r) }) } function Fy(e) { return new Lt(new K(e.url), new K(e.params), new K(e.queryParams), new K(e.fragment), new K(e.data), e.outlet, e.component, e) } var Rr = class { redirectTo; navigationBehaviorOptions; constructor(t, n) { this.redirectTo = t, this.navigationBehaviorOptions = n } }, ip = "ngNavigationCancelingError"; function Ii(e, t) { let { redirectTo: n, navigationBehaviorOptions: r } = yn(t) ? { redirectTo: t, navigationBehaviorOptions: void 0 } : t, o = sp(!1, fe.Redirect); return o.url = n, o.navigationBehaviorOptions = r, o } function sp(e, t) { let n = new Error(`NavigationCancelingError: ${e || ""}`); return n[ip] = !0, n.cancellationCode = t, n } function jy(e) { return ap(e) && yn(e.url) } function ap(e) { return !!e && e[ip] } var Hy = (e, t, n, r) => O(o => (new Mc(t, o.targetRouterState, o.currentRouterState, n, r).activate(e), o)), Mc = class { routeReuseStrategy; futureState; currState; forwardEvent; inputBindingEnabled; constructor(t, n, r, o, i) { this.routeReuseStrategy = t, this.futureState = n, this.currState = r, this.forwardEvent = o, this.inputBindingEnabled = i } activate(t) { let n = this.futureState._root, r = this.currState ? this.currState._root : null; this.deactivateChildRoutes(n, r, t), ic(this.futureState.root), this.activateChildRoutes(n, r, t) } deactivateChildRoutes(t, n, r) { let o = fn(n); t.children.forEach(i => { let s = i.value.outlet; this.deactivateRoutes(i, o[s], r), delete o[s] }), Object.values(o).forEach(i => { this.deactivateRouteAndItsChildren(i, r) }) } deactivateRoutes(t, n, r) { let o = t.value, i = n ? n.value : null; if (o === i) if (o.component) { let s = r.getContext(o.outlet); s && this.deactivateChildRoutes(t, n, s.children) } else this.deactivateChildRoutes(t, n, r); else i && this.deactivateRouteAndItsChildren(n, r) } deactivateRouteAndItsChildren(t, n) { t.value.component && this.routeReuseStrategy.shouldDetach(t.value.snapshot) ? this.detachAndStoreRouteSubtree(t, n) : this.deactivateRouteAndOutlet(t, n) } detachAndStoreRouteSubtree(t, n) { let r = n.getContext(t.value.outlet), o = r && t.value.component ? r.children : n, i = fn(t); for (let s of Object.values(i)) this.deactivateRouteAndItsChildren(s, o); if (r && r.outlet) { let s = r.outlet.detach(), a = r.children.onOutletDeactivated(); this.routeReuseStrategy.store(t.value.snapshot, { componentRef: s, route: t, contexts: a }) } } deactivateRouteAndOutlet(t, n) { let r = n.getContext(t.value.outlet), o = r && t.value.component ? r.children : n, i = fn(t); for (let s of Object.values(i)) this.deactivateRouteAndItsChildren(s, o); r && (r.outlet && (r.outlet.deactivate(), r.children.onOutletDeactivated()), r.attachRef = null, r.route = null) } activateChildRoutes(t, n, r) { let o = fn(n); t.children.forEach(i => { this.activateRoutes(i, o[i.value.outlet], r), this.forwardEvent(new Sc(i.value.snapshot)) }), t.children.length && this.forwardEvent(new Ec(t.value.snapshot)) } activateRoutes(t, n, r) { let o = t.value, i = n ? n.value : null; if (ic(o), o === i) if (o.component) { let s = r.getOrCreateContext(o.outlet); this.activateChildRoutes(t, n, s.children) } else this.activateChildRoutes(t, n, r); else if (o.component) { let s = r.getOrCreateContext(o.outlet); if (this.routeReuseStrategy.shouldAttach(o.snapshot)) { let a = this.routeReuseStrategy.retrieve(o.snapshot); this.routeReuseStrategy.store(o.snapshot, null), s.children.onOutletReAttached(a.contexts), s.attachRef = a.componentRef, s.route = a.route.value, s.outlet && s.outlet.attach(a.componentRef, a.route.value), ic(a.route.value), this.activateChildRoutes(t, null, s.children) } else s.attachRef = null, s.route = o, s.outlet && s.outlet.activateWith(o, s.injector), this.activateChildRoutes(t, null, s.children) } else this.activateChildRoutes(t, null, r) } }, Si = class { path; route; constructor(t) { this.path = t, this.route = this.path[this.path.length - 1] } }, gn = class { component; route; constructor(t, n) { this.component = t, this.route = n } }; function Vy(e, t, n) { let r = e._root, o = t ? t._root : null; return Dr(r, o, n, [r.value]) } function Uy(e) { let t = e.routeConfig ? e.routeConfig.canActivateChild : null; return !t || t.length === 0 ? null : { node: e, guards: t } } function Dn(e, t) { let n = Symbol(), r = t.get(e, n); return r === n ? typeof e == "function" && !ds(e) ? e : t.get(e) : r } function Dr(e, t, n, r, o = { canDeactivateChecks: [], canActivateChecks: [] }) { let i = fn(t); return e.children.forEach(s => { $y(s, i[s.value.outlet], n, r.concat([s.value]), o), delete i[s.value.outlet] }), Object.entries(i).forEach(([s, a]) => Tr(a, n.getContext(s), o)), o } function $y(e, t, n, r, o = { canDeactivateChecks: [], canActivateChecks: [] }) { let i = e.value, s = t ? t.value : null, a = n ? n.getContext(e.value.outlet) : null; if (s && i.routeConfig === s.routeConfig) { let c = By(s, i, i.routeConfig.runGuardsAndResolvers); c ? o.canActivateChecks.push(new Si(r)) : (i.data = s.data, i._resolvedData = s._resolvedData), i.component ? Dr(e, t, a ? a.children : null, r, o) : Dr(e, t, n, r, o), c && a && a.outlet && a.outlet.isActivated && o.canDeactivateChecks.push(new gn(a.outlet.component, s)) } else s && Tr(t, a, o), o.canActivateChecks.push(new Si(r)), i.component ? Dr(e, null, a ? a.children : null, r, o) : Dr(e, null, n, r, o); return o } function By(e, t, n) { if (typeof n == "function") return n(e, t); switch (n) { case "pathParamsChange": return !Pt(e.url, t.url); case "pathParamsOrQueryParamsChange": return !Pt(e.url, t.url) || !je(e.queryParams, t.queryParams); case "always": return !0; case "paramsOrQueryParamsChange": return !Cc(e, t) || !je(e.queryParams, t.queryParams); case "paramsChange": default: return !Cc(e, t) } } function Tr(e, t, n) { let r = fn(e), o = e.value; Object.entries(r).forEach(([i, s]) => { o.component ? t ? Tr(s, t.children.getContext(i), n) : Tr(s, null, n) : Tr(s, t, n) }), o.component ? t && t.outlet && t.outlet.isActivated ? n.canDeactivateChecks.push(new gn(t.outlet.component, o)) : n.canDeactivateChecks.push(new gn(null, o)) : n.canDeactivateChecks.push(new gn(null, o)) } function Lr(e) { return typeof e == "function" } function zy(e) { return typeof e == "boolean" } function qy(e) { return e && Lr(e.canLoad) } function Gy(e) { return e && Lr(e.canActivate) } function Wy(e) { return e && Lr(e.canActivateChild) } function Qy(e) { return e && Lr(e.canDeactivate) } function Zy(e) { return e && Lr(e.canMatch) } function cp(e) { return e instanceof He || e?.name === "EmptyError" } var ci = Symbol("INITIAL_VALUE"); function Sn() { return le(e => ao(e.map(t => t.pipe(Ve(1), Ki(ci)))).pipe(O(t => { for (let n of t) if (n !== !0) { if (n === ci) return ci; if (n === !1 || Yy(n)) return n } return !0 }), Ie(t => t !== ci), Ve(1))) } function Yy(e) { return yn(e) || e instanceof Rr } function Ky(e, t) { return q(n => { let { targetSnapshot: r, currentSnapshot: o, guards: { canActivateChecks: i, canDeactivateChecks: s } } = n; return s.length === 0 && i.length === 0 ? D(V(y({}, n), { guardsResult: !0 })) : Jy(s, r, o, e).pipe(q(a => a && zy(a) ? Xy(r, i, e, t) : D(a)), O(a => V(y({}, n), { guardsResult: a }))) }) } function Jy(e, t, n, r) { return z(e).pipe(q(o => oE(o.component, o.route, n, t, r)), Ue(o => o !== !0, !0)) } function Xy(e, t, n, r) { return z(t).pipe(Zt(o => Qt(tE(o.route.parent, r), eE(o.route, r), rE(e, o.path, n), nE(e, o.route, n))), Ue(o => o !== !0, !0)) } function eE(e, t) { return e !== null && t && t(new Ic(e)), D(!0) } function tE(e, t) { return e !== null && t && t(new yc(e)), D(!0) } function nE(e, t, n) { let r = t.routeConfig ? t.routeConfig.canActivate : null; if (!r || r.length === 0) return D(!0); let o = r.map(i => Rn(() => { let s = wn(t) ?? n, a = Dn(i, s), c = Gy(a) ? a.canActivate(t, e) : oe(s, () => a(t, e)); return Je(c).pipe(Ue()) })); return D(o).pipe(Sn()) } function rE(e, t, n) { let r = t[t.length - 1], i = t.slice(0, t.length - 1).reverse().map(s => Uy(s)).filter(s => s !== null).map(s => Rn(() => { let a = s.guards.map(c => { let l = wn(s.node) ?? n, p = Dn(c, l), h = Wy(p) ? p.canActivateChild(r, e) : oe(l, () => p(r, e)); return Je(h).pipe(Ue()) }); return D(a).pipe(Sn()) })); return D(i).pipe(Sn()) } function oE(e, t, n, r, o) { let i = t && t.routeConfig ? t.routeConfig.canDeactivate : null; if (!i || i.length === 0) return D(!0); let s = i.map(a => { let c = wn(t) ?? o, l = Dn(a, c), p = Qy(l) ? l.canDeactivate(e, t, n, r) : oe(c, () => l(e, t, n, r)); return Je(p).pipe(Ue()) }); return D(s).pipe(Sn()) } function iE(e, t, n, r) { let o = t.canLoad; if (o === void 0 || o.length === 0) return D(!0); let i = o.map(s => { let a = Dn(s, e), c = qy(a) ? a.canLoad(t, n) : oe(e, () => a(t, n)); return Je(c) }); return D(i).pipe(Sn(), lp(r)) } function lp(e) { return zi(Q(t => { if (typeof t != "boolean") throw Ii(e, t) }), O(t => t === !0)) } function sE(e, t, n, r) { let o = t.canMatch; if (!o || o.length === 0) return D(!0); let i = o.map(s => { let a = Dn(s, e), c = Zy(a) ? a.canMatch(t, n) : oe(e, () => a(t, n)); return Je(c) }); return D(i).pipe(Sn(), lp(r)) } var Ar = class { segmentGroup; constructor(t) { this.segmentGroup = t || null } }, Or = class extends Error { urlTree; constructor(t) { super(), this.urlTree = t } }; function dn(e) { return Wt(new Ar(e)) } function aE(e) { return Wt(new E(4e3, !1)) } function cE(e) { return Wt(sp(!1, fe.GuardRejected)) } var _c = class { urlSerializer; urlTree; constructor(t, n) { this.urlSerializer = t, this.urlTree = n } lineralizeSegments(t, n) { let r = [], o = n.root; for (; ;) { if (r = r.concat(o.segments), o.numberOfChildren === 0) return D(r); if (o.numberOfChildren > 1 || !o.children[C]) return aE(`${t.redirectTo}`); o = o.children[C] } } applyRedirectCommands(t, n, r, o, i) { return lE(n, o, i).pipe(O(s => { if (s instanceof Ke) throw new Or(s); let a = this.applyRedirectCreateUrlTree(s, this.urlSerializer.parse(s), t, r); if (s[0] === "/") throw new Or(a); return a })) } applyRedirectCreateUrlTree(t, n, r, o) { let i = this.createSegmentGroup(t, n.root, r, o); return new Ke(i, this.createQueryParams(n.queryParams, this.urlTree.queryParams), n.fragment) } createQueryParams(t, n) { let r = {}; return Object.entries(t).forEach(([o, i]) => { if (typeof i == "string" && i[0] === ":") { let a = i.substring(1); r[o] = n[a] } else r[o] = i }), r } createSegmentGroup(t, n, r, o) { let i = this.createSegments(t, n.segments, r, o), s = {}; return Object.entries(n.children).forEach(([a, c]) => { s[a] = this.createSegmentGroup(t, c, r, o) }), new F(i, s) } createSegments(t, n, r, o) { return n.map(i => i.path[0] === ":" ? this.findPosParam(t, i, o) : this.findOrReturn(i, r)) } findPosParam(t, n, r) { let o = r[n.path.substring(1)]; if (!o) throw new E(4001, !1); return o } findOrReturn(t, n) { let r = 0; for (let o of n) { if (o.path === t.path) return n.splice(r), o; r++ } return t } }; function lE(e, t, n) { if (typeof e == "string") return D(e); let r = e, { queryParams: o, fragment: i, routeConfig: s, url: a, outlet: c, params: l, data: p, title: h } = t; return Je(oe(n, () => r({ params: l, data: p, queryParams: o, fragment: i, routeConfig: s, url: a, outlet: c, title: h }))) } var Nc = { matched: !1, consumedSegments: [], remainingSegments: [], parameters: {}, positionalParamSegments: {} }; function uE(e, t, n, r, o) { let i = up(e, t, n); return i.matched ? (r = Ry(t, r), sE(r, t, n, o).pipe(O(s => s === !0 ? i : y({}, Nc)))) : D(i) } function up(e, t, n) { if (t.path === "**") return dE(n); if (t.path === "") return t.pathMatch === "full" && (e.hasChildren() || n.length > 0) ? y({}, Nc) : { matched: !0, consumedSegments: [], remainingSegments: n, parameters: {}, positionalParamSegments: {} }; let o = (t.matcher || oy)(n, e, t); if (!o) return y({}, Nc); let i = {}; Object.entries(o.posParams ?? {}).forEach(([a, c]) => { i[a] = c.path }); let s = o.consumed.length > 0 ? y(y({}, i), o.consumed[o.consumed.length - 1].parameters) : i; return { matched: !0, consumedSegments: o.consumed, remainingSegments: n.slice(o.consumed.length), parameters: s, positionalParamSegments: o.posParams ?? {} } } function dE(e) { return { matched: !0, parameters: e.length > 0 ? Uf(e).parameters : {}, consumedSegments: e, remainingSegments: [], positionalParamSegments: {} } } function Ff(e, t, n, r) { return n.length > 0 && hE(e, n, r) ? { segmentGroup: new F(t, pE(r, new F(n, e.children))), slicedSegments: [] } : n.length === 0 && gE(e, n, r) ? { segmentGroup: new F(e.segments, fE(e, n, r, e.children)), slicedSegments: n } : { segmentGroup: new F(e.segments, e.children), slicedSegments: n } } function fE(e, t, n, r) { let o = {}; for (let i of n) if (bi(e, t, i) && !r[Re(i)]) { let s = new F([], {}); o[Re(i)] = s } return y(y({}, r), o) } function pE(e, t) { let n = {}; n[C] = t; for (let r of e) if (r.path === "" && Re(r) !== C) { let o = new F([], {}); n[Re(r)] = o } return n } function hE(e, t, n) { return n.some(r => bi(e, t, r) && Re(r) !== C) } function gE(e, t, n) { return n.some(r => bi(e, t, r)) } function bi(e, t, n) { return (e.hasChildren() || t.length > 0) && n.pathMatch === "full" ? !1 : n.path === "" } function mE(e, t, n) { return t.length === 0 && !e.children[n] } var xc = class { }; function vE(e, t, n, r, o, i, s = "emptyOnly") { return new Rc(e, t, n, r, o, s, i).recognize() } var yE = 31, Rc = class { injector; configLoader; rootComponentType; config; urlTree; paramsInheritanceStrategy; urlSerializer; applyRedirects; absoluteRedirectCount = 0; allowRedirects = !0; constructor(t, n, r, o, i, s, a) { this.injector = t, this.configLoader = n, this.rootComponentType = r, this.config = o, this.urlTree = i, this.paramsInheritanceStrategy = s, this.urlSerializer = a, this.applyRedirects = new _c(this.urlSerializer, this.urlTree) } noMatchError(t) { return new E(4002, `'${t.segmentGroup}'`) } recognize() { let t = Ff(this.urlTree.root, [], [], this.config).segmentGroup; return this.match(t).pipe(O(({ children: n, rootSnapshot: r }) => { let o = new Ee(r, n), i = new Ei("", o), s = Dy(r, [], this.urlTree.queryParams, this.urlTree.fragment); return s.queryParams = this.urlTree.queryParams, i.url = this.urlSerializer.serialize(s), { state: i, tree: s } })) } match(t) { let n = new hn([], Object.freeze({}), Object.freeze(y({}, this.urlTree.queryParams)), this.urlTree.fragment, Object.freeze({}), C, this.rootComponentType, null, {}); return this.processSegmentGroup(this.injector, this.config, t, C, n).pipe(O(r => ({ children: r, rootSnapshot: n })), et(r => { if (r instanceof Or) return this.urlTree = r.urlTree, this.match(r.urlTree.root); throw r instanceof Ar ? this.noMatchError(r) : r })) } processSegmentGroup(t, n, r, o, i) { return r.segments.length === 0 && r.hasChildren() ? this.processChildren(t, n, r, i) : this.processSegment(t, n, r, r.segments, o, !0, i).pipe(O(s => s instanceof Ee ? [s] : [])) } processChildren(t, n, r, o) { let i = []; for (let s of Object.keys(r.children)) s === "primary" ? i.unshift(s) : i.push(s); return z(i).pipe(Zt(s => { let a = r.children[s], c = Ay(n, s); return this.processSegmentGroup(t, c, a, s, o) }), Yi((s, a) => (s.push(...a), s)), tt(null), Zi(), q(s => { if (s === null) return dn(r); let a = dp(s); return EE(a), D(a) })) } processSegment(t, n, r, o, i, s, a) { return z(n).pipe(Zt(c => this.processSegmentAgainstRoute(c._injector ?? t, n, c, r, o, i, s, a).pipe(et(l => { if (l instanceof Ar) return D(null); throw l }))), Ue(c => !!c), et(c => { if (cp(c)) return mE(r, o, i) ? D(new xc) : dn(r); throw c })) } processSegmentAgainstRoute(t, n, r, o, i, s, a, c) { return Re(r) !== s && (s === C || !bi(o, i, r)) ? dn(o) : r.redirectTo === void 0 ? this.matchSegmentAgainstRoute(t, o, r, i, s, c) : this.allowRedirects && a ? this.expandSegmentAgainstRouteUsingRedirect(t, o, n, r, i, s, c) : dn(o) } expandSegmentAgainstRouteUsingRedirect(t, n, r, o, i, s, a) { let { matched: c, parameters: l, consumedSegments: p, positionalParamSegments: h, remainingSegments: v } = up(n, o, i); if (!c) return dn(n); typeof o.redirectTo == "string" && o.redirectTo[0] === "/" && (this.absoluteRedirectCount++, this.absoluteRedirectCount > yE && (this.allowRedirects = !1)); let g = new hn(i, l, Object.freeze(y({}, this.urlTree.queryParams)), this.urlTree.fragment, jf(o), Re(o), o.component ?? o._loadedComponent ?? null, o, Hf(o)), w = yi(g, a, this.paramsInheritanceStrategy); return g.params = Object.freeze(w.params), g.data = Object.freeze(w.data), this.applyRedirects.applyRedirectCommands(p, o.redirectTo, h, g, t).pipe(le(H => this.applyRedirects.lineralizeSegments(o, H)), q(H => this.processSegment(t, r, n, H.concat(v), s, !1, a))) } matchSegmentAgainstRoute(t, n, r, o, i, s) { let a = uE(n, r, o, t, this.urlSerializer); return r.path === "**" && (n.children = {}), a.pipe(le(c => c.matched ? (t = r._injector ?? t, this.getChildConfig(t, r, o).pipe(le(({ routes: l }) => { let p = r._loadedInjector ?? t, { parameters: h, consumedSegments: v, remainingSegments: g } = c, w = new hn(v, h, Object.freeze(y({}, this.urlTree.queryParams)), this.urlTree.fragment, jf(r), Re(r), r.component ?? r._loadedComponent ?? null, r, Hf(r)), N = yi(w, s, this.paramsInheritanceStrategy); w.params = Object.freeze(N.params), w.data = Object.freeze(N.data); let { segmentGroup: H, slicedSegments: j } = Ff(n, v, g, l); if (j.length === 0 && H.hasChildren()) return this.processChildren(p, l, H, w).pipe(O(Fr => new Ee(w, Fr))); if (l.length === 0 && j.length === 0) return D(new Ee(w, [])); let bp = Re(r) === i; return this.processSegment(p, l, H, j, bp ? C : i, !0, w).pipe(O(Fr => new Ee(w, Fr instanceof Ee ? [Fr] : []))) }))) : dn(n))) } getChildConfig(t, n, r) { return n.children ? D({ routes: n.children, injector: t }) : n.loadChildren ? n._loadedRoutes !== void 0 ? D({ routes: n._loadedRoutes, injector: n._loadedInjector }) : iE(t, n, r, this.urlSerializer).pipe(q(o => o ? this.configLoader.loadChildren(t, n).pipe(Q(i => { n._loadedRoutes = i.routes, n._loadedInjector = i.injector })) : cE(n))) : D({ routes: [], injector: t }) } }; function EE(e) { e.sort((t, n) => t.value.outlet === C ? -1 : n.value.outlet === C ? 1 : t.value.outlet.localeCompare(n.value.outlet)) } function IE(e) { let t = e.value.routeConfig; return t && t.path === "" } function dp(e) { let t = [], n = new Set; for (let r of e) { if (!IE(r)) { t.push(r); continue } let o = t.find(i => r.value.routeConfig === i.value.routeConfig); o !== void 0 ? (o.children.push(...r.children), n.add(o)) : t.push(r) } for (let r of n) { let o = dp(r.children); t.push(new Ee(r.value, o)) } return t.filter(r => !n.has(r)) } function jf(e) { return e.data || {} } function Hf(e) { return e.resolve || {} } function SE(e, t, n, r, o, i) { return q(s => vE(e, t, n, r, s.extractedUrl, o, i).pipe(O(({ state: a, tree: c }) => V(y({}, s), { targetSnapshot: a, urlAfterRedirects: c })))) } function wE(e, t) { return q(n => { let { targetSnapshot: r, guards: { canActivateChecks: o } } = n; if (!o.length) return D(n); let i = new Set(o.map(c => c.route)), s = new Set; for (let c of i) if (!s.has(c)) for (let l of fp(c)) s.add(l); let a = 0; return z(s).pipe(Zt(c => i.has(c) ? DE(c, r, e, t) : (c.data = yi(c, c.parent, e).resolve, D(void 0))), Q(() => a++), Yt(1), q(c => a === s.size ? D(n) : ae)) }) } function fp(e) { let t = e.children.map(n => fp(n)).flat(); return [e, ...t] } function DE(e, t, n, r) { let o = e.routeConfig, i = e._resolve; return o?.title !== void 0 && !np(o) && (i[kr] = o.title), Rn(() => (e.data = yi(e, e.parent, n).resolve, bE(i, e, t, r).pipe(O(s => (e._resolvedData = s, e.data = y(y({}, e.data), s), null))))) } function bE(e, t, n, r) { let o = cc(e); if (o.length === 0) return D({}); let i = {}; return z(o).pipe(q(s => CE(e[s], t, n, r).pipe(Ue(), Q(a => { if (a instanceof Rr) throw Ii(new vn, a); i[s] = a }))), Yt(1), O(() => i), et(s => cp(s) ? ae : Wt(s))) } function CE(e, t, n, r) { let o = wn(t) ?? r, i = Dn(e, o), s = i.resolve ? i.resolve(t, n) : oe(o, () => i(t, n)); return Je(s) } function sc(e) { return le(t => { let n = e(t); return n ? z(n).pipe(O(() => t)) : D(t) }) } var pp = (() => { class e { buildTitle(n) { let r, o = n.root; for (; o !== void 0;)r = this.getResolvedTitleForRoute(o) ?? r, o = o.children.find(i => i.outlet === C); return r } getResolvedTitleForRoute(n) { return n.data[kr] } static \u0275fac = function (r) { return new (r || e) }; static \u0275prov = S({ token: e, factory: () => m(TE), providedIn: "root" }) } return e })(), TE = (() => { class e extends pp { title; constructor(n) { super(), this.title = n } updateTitle(n) { let r = this.buildTitle(n); r !== void 0 && this.title.setTitle(r) } static \u0275fac = function (r) { return new (r || e)(M(Af)) }; static \u0275prov = S({ token: e, factory: e.\u0275fac, providedIn: "root" }) } return e })(), Ci = new I("", { providedIn: "root", factory: () => ({}) }), Ti = new I(""), hp = (() => { class e { componentLoaders = new WeakMap; childrenLoaders = new WeakMap; onLoadStartListener; onLoadEndListener; compiler = m(Va); loadComponent(n, r) { if (this.componentLoaders.get(r)) return this.componentLoaders.get(r); if (r._loadedComponent) return D(r._loadedComponent); this.onLoadStartListener && this.onLoadStartListener(r); let o = Je(oe(n, () => r.loadComponent())).pipe(O(gp), le(mp), Q(s => { this.onLoadEndListener && this.onLoadEndListener(r), r._loadedComponent = s }), An(() => { this.componentLoaders.delete(r) })), i = new Gt(o, () => new Y).pipe(qt()); return this.componentLoaders.set(r, i), i } loadChildren(n, r) { if (this.childrenLoaders.get(r)) return this.childrenLoaders.get(r); if (r._loadedRoutes) return D({ routes: r._loadedRoutes, injector: r._loadedInjector }); this.onLoadStartListener && this.onLoadStartListener(r); let i = ME(r, this.compiler, n, this.onLoadEndListener).pipe(An(() => { this.childrenLoaders.delete(r) })), s = new Gt(i, () => new Y).pipe(qt()); return this.childrenLoaders.set(r, s), s } static \u0275fac = function (r) { return new (r || e) }; static \u0275prov = S({ token: e, factory: e.\u0275fac, providedIn: "root" }) } return e })(); function ME(e, t, n, r) { return Je(oe(n, () => e.loadChildren())).pipe(O(gp), le(mp), q(o => o instanceof Jo || Array.isArray(o) ? D(o) : z(t.compileModuleAsync(o))), O(o => { r && r(e); let i, s, a = !1; return Array.isArray(o) ? (s = o, a = !0) : (i = o.create(n).injector, s = i.get(Ti, [], { optional: !0, self: !0 }).flat()), { routes: s.map(kc), injector: i } })) } function _E(e) { return e && typeof e == "object" && "default" in e } function gp(e) { return _E(e) ? e.default : e } function mp(e) { return D(e) } var Pc = (() => { class e { static \u0275fac = function (r) { return new (r || e) }; static \u0275prov = S({ token: e, factory: () => m(NE), providedIn: "root" }) } return e })(), NE = (() => { class e { shouldProcessUrl(n) { return !0 } extract(n) { return n } merge(n, r) { return n } static \u0275fac = function (r) { return new (r || e) }; static \u0275prov = S({ token: e, factory: e.\u0275fac, providedIn: "root" }) } return e })(), vp = new I(""); var yp = new I(""), Ep = (() => { class e { currentNavigation = Jn(null, { equal: () => !1 }); currentTransition = null; lastSuccessfulNavigation = null; events = new Y; transitionAbortWithErrorSubject = new Y; configLoader = m(hp); environmentInjector = m(J); destroyRef = m(_t); urlSerializer = m(wi); rootContexts = m(Pr); location = m(un); inputBindingEnabled = m(Di, { optional: !0 }) !== null; titleStrategy = m(pp); options = m(Ci, { optional: !0 }) || {}; paramsInheritanceStrategy = this.options.paramsInheritanceStrategy || "emptyOnly"; urlHandlingStrategy = m(Pc); createViewTransition = m(vp, { optional: !0 }); navigationErrorHandler = m(yp, { optional: !0 }); navigationId = 0; get hasRequestedNavigation() { return this.navigationId !== 0 } transitions; afterPreactivation = () => D(void 0); rootComponentType = null; destroyed = !1; constructor() { let n = o => this.events.next(new mc(o)), r = o => this.events.next(new vc(o)); this.configLoader.onLoadEndListener = r, this.configLoader.onLoadStartListener = n, this.destroyRef.onDestroy(() => { this.destroyed = !0 }) } complete() { this.transitions?.complete() } handleNavigationRequest(n) { let r = ++this.navigationId; lt(() => { this.transitions?.next(V(y({}, n), { extractedUrl: this.urlHandlingStrategy.extract(n.rawUrl), targetSnapshot: null, targetRouterState: null, guards: { canActivateChecks: [], canDeactivateChecks: [] }, guardsResult: null, abortController: new AbortController, id: r })) }) } setupNavigations(n) { return this.transitions = new K(null), this.transitions.pipe(Ie(r => r !== null), le(r => { let o = !1; return D(r).pipe(le(i => { if (this.navigationId > r.id) return this.cancelNavigationTransition(r, "", fe.SupersededByNewNavigation), ae; this.currentTransition = r, this.currentNavigation.set({ id: i.id, initialUrl: i.rawUrl, extractedUrl: i.extractedUrl, targetBrowserUrl: typeof i.extras.browserUrl == "string" ? this.urlSerializer.parse(i.extras.browserUrl) : i.extras.browserUrl, trigger: i.source, extras: i.extras, previousNavigation: this.lastSuccessfulNavigation ? V(y({}, this.lastSuccessfulNavigation), { previousNavigation: null }) : null, abort: () => i.abortController.abort() }); let s = !n.navigated || this.isUpdatingInternalState() || this.isUpdatedBrowserUrl(), a = i.extras.onSameUrlNavigation ?? n.onSameUrlNavigation; if (!s && a !== "reload") return this.events.next(new ft(i.id, this.urlSerializer.serialize(i.rawUrl), "", hi.IgnoredSameUrlNavigation)), i.resolve(!1), ae; if (this.urlHandlingStrategy.shouldProcessUrl(i.rawUrl)) return D(i).pipe(le(c => (this.events.next(new En(c.id, this.urlSerializer.serialize(c.extractedUrl), c.source, c.restoredState)), c.id !== this.navigationId ? ae : Promise.resolve(c))), SE(this.environmentInjector, this.configLoader, this.rootComponentType, n.config, this.urlSerializer, this.paramsInheritanceStrategy), Q(c => { r.targetSnapshot = c.targetSnapshot, r.urlAfterRedirects = c.urlAfterRedirects, this.currentNavigation.update(p => (p.finalUrl = c.urlAfterRedirects, p)); let l = new gi(c.id, this.urlSerializer.serialize(c.extractedUrl), this.urlSerializer.serialize(c.urlAfterRedirects), c.targetSnapshot); this.events.next(l) })); if (s && this.urlHandlingStrategy.shouldProcessUrl(i.currentRawUrl)) { let { id: c, extractedUrl: l, source: p, restoredState: h, extras: v } = i, g = new En(c, this.urlSerializer.serialize(l), p, h); this.events.next(g); let w = ep(this.rootComponentType).snapshot; return this.currentTransition = r = V(y({}, i), { targetSnapshot: w, urlAfterRedirects: l, extras: V(y({}, v), { skipLocationChange: !1, replaceUrl: !1 }) }), this.currentNavigation.update(N => (N.finalUrl = l, N)), D(r) } else return this.events.next(new ft(i.id, this.urlSerializer.serialize(i.extractedUrl), "", hi.IgnoredByUrlHandlingStrategy)), i.resolve(!1), ae }), Q(i => { let s = new fc(i.id, this.urlSerializer.serialize(i.extractedUrl), this.urlSerializer.serialize(i.urlAfterRedirects), i.targetSnapshot); this.events.next(s) }), O(i => (this.currentTransition = r = V(y({}, i), { guards: Vy(i.targetSnapshot, i.currentSnapshot, this.rootContexts) }), r)), Ky(this.environmentInjector, i => this.events.next(i)), Q(i => { if (r.guardsResult = i.guardsResult, i.guardsResult && typeof i.guardsResult != "boolean") throw Ii(this.urlSerializer, i.guardsResult); let s = new pc(i.id, this.urlSerializer.serialize(i.extractedUrl), this.urlSerializer.serialize(i.urlAfterRedirects), i.targetSnapshot, !!i.guardsResult); this.events.next(s) }), Ie(i => i.guardsResult ? !0 : (this.cancelNavigationTransition(i, "", fe.GuardRejected), !1)), sc(i => { if (i.guards.canActivateChecks.length !== 0) return D(i).pipe(Q(s => { let a = new hc(s.id, this.urlSerializer.serialize(s.extractedUrl), this.urlSerializer.serialize(s.urlAfterRedirects), s.targetSnapshot); this.events.next(a) }), le(s => { let a = !1; return D(s).pipe(wE(this.paramsInheritanceStrategy, this.environmentInjector), Q({ next: () => a = !0, complete: () => { a || this.cancelNavigationTransition(s, "", fe.NoDataFromResolver) } })) }), Q(s => { let a = new gc(s.id, this.urlSerializer.serialize(s.extractedUrl), this.urlSerializer.serialize(s.urlAfterRedirects), s.targetSnapshot); this.events.next(a) })) }), sc(i => { let s = a => { let c = []; if (a.routeConfig?.loadComponent) { let l = wn(a) ?? this.environmentInjector; c.push(this.configLoader.loadComponent(l, a.routeConfig).pipe(Q(p => { a.component = p }), O(() => { }))) } for (let l of a.children) c.push(...s(l)); return c }; return ao(s(i.targetSnapshot.root)).pipe(tt(null), Ve(1)) }), sc(() => this.afterPreactivation()), le(() => { let { currentSnapshot: i, targetSnapshot: s } = r, a = this.createViewTransition?.(this.environmentInjector, i.root, s.root); return a ? z(a).pipe(O(() => r)) : D(r) }), O(i => { let s = Py(n.routeReuseStrategy, i.targetSnapshot, i.currentRouterState); return this.currentTransition = r = V(y({}, i), { targetRouterState: s }), this.currentNavigation.update(a => (a.targetRouterState = s, a)), r }), Q(() => { this.events.next(new Nr) }), Hy(this.rootContexts, n.routeReuseStrategy, i => this.events.next(i), this.inputBindingEnabled), Ve(1), lo(new k(i => { let s = r.abortController.signal, a = () => i.next(); return s.addEventListener("abort", a), () => s.removeEventListener("abort", a) }).pipe(Ie(() => !o && !r.targetRouterState), Q(() => { this.cancelNavigationTransition(r, r.abortController.signal.reason + "", fe.Aborted) }))), Q({ next: i => { o = !0, this.lastSuccessfulNavigation = lt(this.currentNavigation), this.events.next(new dt(i.id, this.urlSerializer.serialize(i.extractedUrl), this.urlSerializer.serialize(i.urlAfterRedirects))), this.titleStrategy?.updateTitle(i.targetRouterState.snapshot), i.resolve(!0) }, complete: () => { o = !0 } }), lo(this.transitionAbortWithErrorSubject.pipe(Q(i => { throw i }))), An(() => { o || this.cancelNavigationTransition(r, "", fe.SupersededByNewNavigation), this.currentTransition?.id === r.id && (this.currentNavigation.set(null), this.currentTransition = null) }), et(i => { if (this.destroyed) return r.resolve(!1), ae; if (o = !0, ap(i)) this.events.next(new Ye(r.id, this.urlSerializer.serialize(r.extractedUrl), i.message, i.cancellationCode)), jy(i) ? this.events.next(new In(i.url, i.navigationBehaviorOptions)) : r.resolve(!1); else { let s = new _r(r.id, this.urlSerializer.serialize(r.extractedUrl), i, r.targetSnapshot ?? void 0); try { let a = oe(this.environmentInjector, () => this.navigationErrorHandler?.(s)); if (a instanceof Rr) { let { message: c, cancellationCode: l } = Ii(this.urlSerializer, a); this.events.next(new Ye(r.id, this.urlSerializer.serialize(r.extractedUrl), c, l)), this.events.next(new In(a.redirectTo, a.navigationBehaviorOptions)) } else throw this.events.next(s), i } catch (a) { this.options.resolveNavigationPromiseOnError ? r.resolve(!1) : r.reject(a) } } return ae })) })) } cancelNavigationTransition(n, r, o) { let i = new Ye(n.id, this.urlSerializer.serialize(n.extractedUrl), r, o); this.events.next(i), n.resolve(!1) } isUpdatingInternalState() { return this.currentTransition?.extractedUrl.toString() !== this.currentTransition?.currentUrlTree.toString() } isUpdatedBrowserUrl() { let n = this.urlHandlingStrategy.extract(this.urlSerializer.parse(this.location.path(!0))), r = lt(this.currentNavigation), o = r?.targetBrowserUrl ?? r?.extractedUrl; return n.toString() !== o?.toString() && !r?.extras.skipLocationChange } static \u0275fac = function (r) { return new (r || e) }; static \u0275prov = S({ token: e, factory: e.\u0275fac, providedIn: "root" }) } return e })(); function xE(e) { return e !== Cr } var RE = (() => { class e { static \u0275fac = function (r) { return new (r || e) }; static \u0275prov = S({ token: e, factory: () => m(AE), providedIn: "root" }) } return e })(), Ac = class { shouldDetach(t) { return !1 } store(t, n) { } shouldAttach(t) { return !1 } retrieve(t) { return null } shouldReuseRoute(t, n) { return t.routeConfig === n.routeConfig } }, AE = (() => { class e extends Ac { static \u0275fac = (() => { let n; return function (o) { return (n || (n = Bo(e)))(o || e) } })(); static \u0275prov = S({ token: e, factory: e.\u0275fac, providedIn: "root" }) } return e })(), Ip = (() => { class e { urlSerializer = m(wi); options = m(Ci, { optional: !0 }) || {}; canceledNavigationResolution = this.options.canceledNavigationResolution || "replace"; location = m(un); urlHandlingStrategy = m(Pc); urlUpdateStrategy = this.options.urlUpdateStrategy || "deferred"; currentUrlTree = new Ke; getCurrentUrlTree() { return this.currentUrlTree } rawUrlTree = this.currentUrlTree; getRawUrlTree() { return this.rawUrlTree } createBrowserPath({ finalUrl: n, initialUrl: r, targetBrowserUrl: o }) { let i = n !== void 0 ? this.urlHandlingStrategy.merge(n, r) : r, s = o ?? i; return s instanceof Ke ? this.urlSerializer.serialize(s) : s } commitTransition({ targetRouterState: n, finalUrl: r, initialUrl: o }) { r && n ? (this.currentUrlTree = r, this.rawUrlTree = this.urlHandlingStrategy.merge(r, o), this.routerState = n) : this.rawUrlTree = o } routerState = ep(null); getRouterState() { return this.routerState } stateMemento = this.createStateMemento(); updateStateMemento() { this.stateMemento = this.createStateMemento() } createStateMemento() { return { rawUrlTree: this.rawUrlTree, currentUrlTree: this.currentUrlTree, routerState: this.routerState } } resetInternalState({ finalUrl: n }) { this.routerState = this.stateMemento.routerState, this.currentUrlTree = this.stateMemento.currentUrlTree, this.rawUrlTree = this.urlHandlingStrategy.merge(this.currentUrlTree, n ?? this.rawUrlTree) } static \u0275fac = function (r) { return new (r || e) }; static \u0275prov = S({ token: e, factory: () => m(OE), providedIn: "root" }) } return e })(), OE = (() => { class e extends Ip { currentPageId = 0; lastSuccessfulId = -1; restoredState() { return this.location.getState() } get browserPageId() { return this.canceledNavigationResolution !== "computed" ? this.currentPageId : this.restoredState()?.\u0275routerPageId ?? this.currentPageId } registerNonRouterCurrentEntryChangeListener(n) { return this.location.subscribe(r => { r.type === "popstate" && setTimeout(() => { n(r.url, r.state, "popstate") }) }) } handleRouterEvent(n, r) { n instanceof En ? this.updateStateMemento() : n instanceof ft ? this.commitTransition(r) : n instanceof gi ? this.urlUpdateStrategy === "eager" && (r.extras.skipLocationChange || this.setBrowserUrl(this.createBrowserPath(r), r)) : n instanceof Nr ? (this.commitTransition(r), this.urlUpdateStrategy === "deferred" && !r.extras.skipLocationChange && this.setBrowserUrl(this.createBrowserPath(r), r)) : n instanceof Ye && n.code !== fe.SupersededByNewNavigation && n.code !== fe.Redirect ? this.restoreHistory(r) : n instanceof _r ? this.restoreHistory(r, !0) : n instanceof dt && (this.lastSuccessfulId = n.id, this.currentPageId = this.browserPageId) } setBrowserUrl(n, { extras: r, id: o }) { let { replaceUrl: i, state: s } = r; if (this.location.isCurrentPathEqualTo(n) || i) { let a = this.browserPageId, c = y(y({}, s), this.generateNgRouterState(o, a)); this.location.replaceState(n, "", c) } else { let a = y(y({}, s), this.generateNgRouterState(o, this.browserPageId + 1)); this.location.go(n, "", a) } } restoreHistory(n, r = !1) { if (this.canceledNavigationResolution === "computed") { let o = this.browserPageId, i = this.currentPageId - o; i !== 0 ? this.location.historyGo(i) : this.getCurrentUrlTree() === n.finalUrl && i === 0 && (this.resetInternalState(n), this.resetUrlToCurrentUrlTree()) } else this.canceledNavigationResolution === "replace" && (r && this.resetInternalState(n), this.resetUrlToCurrentUrlTree()) } resetUrlToCurrentUrlTree() { this.location.replaceState(this.urlSerializer.serialize(this.getRawUrlTree()), "", this.generateNgRouterState(this.lastSuccessfulId, this.currentPageId)) } generateNgRouterState(n, r) { return this.canceledNavigationResolution === "computed" ? { navigationId: n, \u0275routerPageId: r } : { navigationId: n } } static \u0275fac = (() => { let n; return function (o) { return (n || (n = Bo(e)))(o || e) } })(); static \u0275prov = S({ token: e, factory: e.\u0275fac, providedIn: "root" }) } return e })(); function Sp(e, t) { e.events.pipe(Ie(n => n instanceof dt || n instanceof Ye || n instanceof _r || n instanceof ft), O(n => n instanceof dt || n instanceof ft ? 0 : (n instanceof Ye ? n.code === fe.Redirect || n.code === fe.SupersededByNewNavigation : !1) ? 2 : 1), Ie(n => n !== 2), Ve(1)).subscribe(() => { t() }) } var kE = { paths: "exact", fragment: "ignored", matrixParams: "ignored", queryParams: "exact" }, PE = { paths: "subset", fragment: "ignored", matrixParams: "ignored", queryParams: "subset" }, Lc = (() => { class e { get currentUrlTree() { return this.stateManager.getCurrentUrlTree() } get rawUrlTree() { return this.stateManager.getRawUrlTree() } disposed = !1; nonRouterCurrentEntryChangeSubscription; console = m(Pa); stateManager = m(Ip); options = m(Ci, { optional: !0 }) || {}; pendingTasks = m(We); urlUpdateStrategy = this.options.urlUpdateStrategy || "deferred"; navigationTransitions = m(Ep); urlSerializer = m(wi); location = m(un); urlHandlingStrategy = m(Pc); injector = m(J); _events = new Y; get events() { return this._events } get routerState() { return this.stateManager.getRouterState() } navigated = !1; routeReuseStrategy = m(RE); onSameUrlNavigation = this.options.onSameUrlNavigation || "ignore"; config = m(Ti, { optional: !0 })?.flat() ?? []; componentInputBindingEnabled = !!m(Di, { optional: !0 }); currentNavigation = this.navigationTransitions.currentNavigation.asReadonly(); constructor() { this.resetConfig(this.config), this.navigationTransitions.setupNavigations(this).subscribe({ error: n => { this.console.warn(n) } }), this.subscribeToNavigationEvents() } eventsSubscription = new B; subscribeToNavigationEvents() { let n = this.navigationTransitions.events.subscribe(r => { try { let o = this.navigationTransitions.currentTransition, i = lt(this.navigationTransitions.currentNavigation); if (o !== null && i !== null) { if (this.stateManager.handleRouterEvent(r, i), r instanceof Ye && r.code !== fe.Redirect && r.code !== fe.SupersededByNewNavigation) this.navigated = !0; else if (r instanceof dt) this.navigated = !0; else if (r instanceof In) { let s = r.navigationBehaviorOptions, a = this.urlHandlingStrategy.merge(r.url, o.currentRawUrl), c = y({ browserUrl: o.extras.browserUrl, info: o.extras.info, skipLocationChange: o.extras.skipLocationChange, replaceUrl: o.extras.replaceUrl || this.urlUpdateStrategy === "eager" || xE(o.source) }, s); this.scheduleNavigation(a, Cr, null, c, { resolve: o.resolve, reject: o.reject, promise: o.promise }) } } xy(r) && this._events.next(r) } catch (o) { this.navigationTransitions.transitionAbortWithErrorSubject.next(o) } }); this.eventsSubscription.add(n) } resetRootComponentType(n) { this.routerState.root.component = n, this.navigationTransitions.rootComponentType = n } initialNavigation() { this.setUpLocationChangeListener(), this.navigationTransitions.hasRequestedNavigation || this.navigateToSyncWithBrowser(this.location.path(!0), Cr, this.stateManager.restoredState()) } setUpLocationChangeListener() { this.nonRouterCurrentEntryChangeSubscription ??= this.stateManager.registerNonRouterCurrentEntryChangeListener((n, r, o) => { this.navigateToSyncWithBrowser(n, o, r) }) } navigateToSyncWithBrowser(n, r, o) { let i = { replaceUrl: !0 }, s = o?.navigationId ? o : null; if (o) { let c = y({}, o); delete c.navigationId, delete c.\u0275routerPageId, Object.keys(c).length !== 0 && (i.state = c) } let a = this.parseUrl(n); this.scheduleNavigation(a, r, s, i).catch(c => { this.disposed || this.injector.get(Ne)(c) }) } get url() { return this.serializeUrl(this.currentUrlTree) } getCurrentNavigation() { return lt(this.navigationTransitions.currentNavigation) } get lastSuccessfulNavigation() { return this.navigationTransitions.lastSuccessfulNavigation } resetConfig(n) { this.config = n.map(kc), this.navigated = !1 } ngOnDestroy() { this.dispose() } dispose() { this._events.unsubscribe(), this.navigationTransitions.complete(), this.nonRouterCurrentEntryChangeSubscription && (this.nonRouterCurrentEntryChangeSubscription.unsubscribe(), this.nonRouterCurrentEntryChangeSubscription = void 0), this.disposed = !0, this.eventsSubscription.unsubscribe() } createUrlTree(n, r = {}) { let { relativeTo: o, queryParams: i, fragment: s, queryParamsHandling: a, preserveFragment: c } = r, l = c ? this.currentUrlTree.fragment : s, p = null; switch (a ?? this.options.defaultQueryParamsHandling) { case "merge": p = y(y({}, this.currentUrlTree.queryParams), i); break; case "preserve": p = this.currentUrlTree.queryParams; break; default: p = i || null }p !== null && (p = this.removeEmptyProps(p)); let h; try { let v = o ? o.snapshot : this.routerState.snapshot.root; h = Yf(v) } catch { (typeof n[0] != "string" || n[0][0] !== "/") && (n = []), h = this.currentUrlTree.root } return Kf(h, n, p, l ?? null) } navigateByUrl(n, r = { skipLocationChange: !1 }) { let o = yn(n) ? n : this.parseUrl(n), i = this.urlHandlingStrategy.merge(o, this.rawUrlTree); return this.scheduleNavigation(i, Cr, null, r) } navigate(n, r = { skipLocationChange: !1 }) { return LE(n), this.navigateByUrl(this.createUrlTree(n, r), r) } serializeUrl(n) { return this.urlSerializer.serialize(n) } parseUrl(n) { try { return this.urlSerializer.parse(n) } catch { return this.console.warn(Ln(4018, !1)), this.urlSerializer.parse("/") } } isActive(n, r) { let o; if (r === !0 ? o = y({}, kE) : r === !1 ? o = y({}, PE) : o = r, yn(n)) return Of(this.currentUrlTree, n, o); let i = this.parseUrl(n); return Of(this.currentUrlTree, i, o) } removeEmptyProps(n) { return Object.entries(n).reduce((r, [o, i]) => (i != null && (r[o] = i), r), {}) } scheduleNavigation(n, r, o, i, s) { if (this.disposed) return Promise.resolve(!1); let a, c, l; s ? (a = s.resolve, c = s.reject, l = s.promise) : l = new Promise((h, v) => { a = h, c = v }); let p = this.pendingTasks.add(); return Sp(this, () => { queueMicrotask(() => this.pendingTasks.remove(p)) }), this.navigationTransitions.handleNavigationRequest({ source: r, restoredState: o, currentUrlTree: this.currentUrlTree, currentRawUrl: this.currentUrlTree, rawUrl: n, extras: i, resolve: a, reject: c, promise: l, currentSnapshot: this.routerState.snapshot, currentRouterState: this.routerState }), l.catch(h => Promise.reject(h)) } static \u0275fac = function (r) { return new (r || e) }; static \u0275prov = S({ token: e, factory: e.\u0275fac, providedIn: "root" }) } return e })(); function LE(e) { for (let t = 0; t < e.length; t++)if (e[t] == null) throw new E(4008, !1) } var FE = new I(""); function Fc(e, ...t) { return Dt([{ provide: Ti, multi: !0, useValue: e }, [], { provide: Lt, useFactory: jE, deps: [Lc] }, { provide: Xo, multi: !0, useFactory: HE }, t.map(n => n.\u0275providers)]) } function jE(e) { return e.routerState.root } function HE() { let e = m(Oe); return t => { let n = e.get(Ot); if (t !== n.components[0]) return; let r = e.get(Lc), o = e.get(VE); e.get(UE) === 1 && r.initialNavigation(), e.get($E, null, { optional: !0 })?.setUpPreloading(), e.get(FE, null, { optional: !0 })?.init(), r.resetRootComponentType(n.componentTypes[0]), o.closed || (o.next(), o.complete(), o.unsubscribe()) } } var VE = new I("", { factory: () => new Y }), UE = new I("", { providedIn: "root", factory: () => 1 }); var $E = new I(""); var wp = []; var Dp = { providers: [Zs(), $a(), Fc(wp)] }; var Mi = class e { sheetEndpoint = "https://script.google.com/macros/s/AKfycbyRjVZe8soljesxTUJ5CjmliwN4dc7ECGBVcRrP3v_YevXfXZ4QxrQhcu6oGZ95_D3daA/exec"; cleanupFns = []; navObserver; revealObserver; toastTimer; themeButton; ngAfterViewInit() { this.initTheme(), this.initRevealAnimations(), this.initMobileMenu(); let t = Array.from(document.querySelectorAll('.nav-links a[href^="#"]')), n = Array.from(document.querySelectorAll("main section")); t.length && n.length && (this.navObserver = new IntersectionObserver(s => { s.forEach(a => { if (a.isIntersecting) { let c = a.target.getAttribute("id"); t.forEach(l => { l.classList.toggle("active", l.getAttribute("href") === `#${c}`) }) } }) }, { threshold: .5 }), n.forEach(s => this.navObserver?.observe(s))), Array.from(document.querySelectorAll(".faq-item button")).forEach(s => { let a = () => { let c = s.closest(".faq-item"); if (!c) return; let l = c.classList.toggle("open"); s.setAttribute("aria-expanded", String(l)); let p = s.querySelector("span"); p && (p.textContent = l ? "-" : "+") }; s.addEventListener("click", a), this.cleanupFns.push(() => s.removeEventListener("click", a)) }); let o = document.getElementById("contact-form"), i = document.getElementById("toast"); if (o && i) { let s = a => { a.preventDefault(); let c = new FormData(o), l = new URLSearchParams; c.forEach((p, h) => l.append(h, String(p))), fetch(this.sheetEndpoint, { method: "POST", body: l, mode: "no-cors" }), i.classList.add("show"), o.reset(), this.toastTimer && clearTimeout(this.toastTimer), this.toastTimer = setTimeout(() => i.classList.remove("show"), 2600) }; o.addEventListener("submit", s), this.cleanupFns.push(() => o.removeEventListener("submit", s)) } } ngOnDestroy() { this.navObserver?.disconnect(), this.revealObserver?.disconnect(), this.cleanupFns.forEach(t => t()), this.toastTimer && clearTimeout(this.toastTimer) } initTheme() { let t = document.documentElement, n = localStorage.getItem("theme"), r = window.matchMedia && window.matchMedia("(prefers-color-scheme: dark)").matches, o = n === "light" || n === "dark" ? n : r ? "dark" : "light"; if (t.setAttribute("data-theme", o), this.themeButton = document.querySelector(".theme-toggle"), !this.themeButton) return; let i = a => { let c = this.themeButton?.querySelector(".theme-toggle__text"); c && (c.textContent = a === "dark" ? "Light" : "Dark"), this.themeButton?.setAttribute("aria-pressed", String(a === "dark")) }; i(o); let s = () => { let c = (t.getAttribute("data-theme") === "dark" ? "dark" : "light") === "dark" ? "light" : "dark"; t.setAttribute("data-theme", c), localStorage.setItem("theme", c), i(c) }; this.themeButton.addEventListener("click", s), this.cleanupFns.push(() => this.themeButton?.removeEventListener("click", s)) } initRevealAnimations() { let t = new Set; Array.from(document.querySelectorAll('[data-animate="reveal"]')).forEach(o => t.add(o)), Array.from(document.querySelectorAll("[data-stagger]")).forEach(o => { Array.from(o.children).forEach((s, a) => { s.style.setProperty("--delay", `${a * .08}s`), t.add(s) }) }), t.size !== 0 && (this.revealObserver = new IntersectionObserver(o => { o.forEach(i => { i.isIntersecting && (i.target.classList.add("is-visible"), this.revealObserver?.unobserve(i.target)) }) }, { threshold: .2, rootMargin: "0px 0px -10% 0px" }), t.forEach(o => { o.classList.add("reveal-on-scroll"), this.revealObserver?.observe(o) })) } initMobileMenu() { let t = document.querySelector(".menu-toggle"), n = document.querySelector(".nav-links"); if (!t || !n) return; let r = () => { n.classList.remove("open"), t.setAttribute("aria-expanded", "false") }, o = () => { let s = n.classList.toggle("open"); t.setAttribute("aria-expanded", String(s)) }; t.addEventListener("click", o), this.cleanupFns.push(() => t.removeEventListener("click", o)); let i = () => r(); n.querySelectorAll("a").forEach(s => { s.addEventListener("click", i), this.cleanupFns.push(() => s.removeEventListener("click", i)) }), window.addEventListener("resize", r), this.cleanupFns.push(() => window.removeEventListener("resize", r)) } static \u0275fac = function (n) { return new (n || e) }; static \u0275cmp = fr({ type: e, selectors: [["app-root"]], decls: 565, vars: 0, consts: [["href", "#main", 1, "skip-link"], ["aria-label", "Primary", 1, "container", "nav"], ["href", "#hero", "aria-label", "Codebase home", 1, "logo"], [1, "logo-mark"], ["type", "button", "aria-label", "Toggle navigation", "aria-expanded", "false", 1, "menu-toggle"], ["role", "navigation", 1, "nav-links"], ["href", "#services"], ["href", "#projects"], ["href", "#process"], ["href", "#tech"], ["href", "#faq"], ["href", "#contact"], ["type", "button", "aria-label", "Toggle color theme", 1, "theme-toggle"], ["aria-hidden", "true", 1, "theme-toggle__icon"], [1, "theme-toggle__text"], ["href", "#contact", 1, "cta"], ["id", "main"], ["id", "hero", 1, "hero"], ["data-animate", "reveal", 1, "container", "hero-grid"], [1, "hero-actions"], ["href", "#services", 1, "cta", "secondary"], ["aria-label", "Trust highlights", 1, "trust-row"], [1, "glass-strong", 2, "padding", "26px"], [2, "margin-top", "0"], [2, "color", "var(--muted)"], [1, "cards", 2, "grid-template-columns", "repeat(2, minmax(140px, 1fr))"], [1, "card", "glass"], ["aria-hidden", "true", 1, "icon"], ["width", "22", "height", "22", "viewBox", "0 0 24 24", "fill", "none", "stroke", "currentColor", "stroke-width", "2"], ["d", "M4 7h16M4 12h16M4 17h10"], ["d", "M12 3l9 4.5-9 4.5-9-4.5 9-4.5z"], ["d", "M3 12l9 4.5 9-4.5"], ["cx", "12", "cy", "12", "r", "9"], ["d", "M12 7v5l3 3"], ["d", "M3 7h18v10H3z"], ["d", "M7 7V5h10v2"], ["id", "services"], [1, "container"], ["data-animate", "reveal", 1, "section-title"], ["data-stagger", "", 1, "cards"], ["aria-label", "Full-Stack Web", 1, "card", "glass"], ["x", "3", "y", "4", "width", "18", "height", "14", "rx", "2"], ["d", "M8 20h8"], ["aria-label", "Mobile Apps", 1, "card", "glass"], ["x", "7", "y", "2", "width", "10", "height", "20", "rx", "2"], ["cx", "12", "cy", "18", "r", "1"], ["aria-label", "IoT Systems", 1, "card", "glass"], ["d", "M7 9a5 5 0 0 1 10 0"], ["d", "M5 13a7 7 0 0 1 14 0"], ["cx", "12", "cy", "17", "r", "2"], ["aria-label", "Machine Learning", 1, "card", "glass"], ["d", "M12 2v4M12 18v4M2 12h4M18 12h4"], ["cx", "12", "cy", "12", "r", "5"], ["aria-label", "Deep Learning", 1, "card", "glass"], ["d", "M4 7h16"], ["d", "M4 12h16"], ["d", "M4 17h16"], ["cx", "8", "cy", "7", "r", "2"], ["cx", "16", "cy", "12", "r", "2"], ["cx", "8", "cy", "17", "r", "2"], ["aria-label", "Cybersecurity", 1, "card", "glass"], ["d", "M12 2l8 4v6c0 5-3.5 9-8 10-4.5-1-8-5-8-10V6l8-4z"], ["d", "M9 12l2 2 4-4"], ["aria-label", "DevOps and Cloud", 1, "card", "glass"], ["d", "M12 2l7 5v10l-7 5-7-5V7z"], ["d", "M12 8v8"], ["aria-label", "UI and UX Design", 1, "card", "glass"], ["d", "M7 8h6"], ["d", "M7 12h10"], ["aria-label", "Report Writing", 1, "card", "glass"], ["d", "M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"], ["d", "M14 2v6h6"], ["d", "M8 13h8"], ["d", "M8 17h6"], ["aria-label", "Project Consulting", 1, "card", "glass"], ["d", "M12 20v-6"], ["d", "M6 20v-4"], ["d", "M18 20v-8"], ["cx", "12", "cy", "6", "r", "3"], ["id", "projects"], ["data-stagger", "", 1, "project-grid"], [1, "project-card", "glass"], [1, "project-header"], [1, "project-tag"], [1, "project-meta"], ["id", "process"], ["data-stagger", "", 1, "timeline"], [1, "step", "glass"], [1, "step-num"], [2, "color", "var(--muted)", "margin", "6px 0 0"], ["id", "tech"], ["data-animate", "reveal", 1, "tech-panel", "glass-strong"], ["data-stagger", "", 1, "tech-grid"], [1, "pill"], ["id", "faq"], ["data-stagger", "", 1, "faq"], [1, "faq-item", "glass"], ["type", "button", "aria-expanded", "false"], [1, "faq-content"], ["id", "contact"], ["data-stagger", "", 1, "contact-grid"], [1, "glass-strong", "contact-card", 2, "padding", "24px"], ["id", "contact-form", "aria-label", "Contact form"], ["for", "name"], ["id", "name", "name", "name", "type", "text", "autocomplete", "name", "required", ""], ["for", "email"], ["id", "email", "name", "email", "type", "email", "autocomplete", "email", "required", ""], ["for", "phone"], ["id", "phone", "name", "phone", "type", "tel", "autocomplete", "tel"], ["for", "type"], ["id", "type", "name", "type", "required", ""], ["value", ""], ["for", "message"], ["id", "message", "name", "message", "required", ""], ["type", "submit", 1, "cta"], [1, "glass", "contact-card", 2, "padding", "22px"], [1, "contact-list"], ["href", "https://wa.me/94723264256", "target", "_blank", "rel", "noopener", 1, "contact-pill", "contact-pill--whatsapp"], ["href", "tel:+94723264256", 1, "contact-pill", "contact-pill--call"], ["href", "mailto:info.codebaselk@gmail.com", 1, "contact-pill", "contact-pill--email"], ["href", "https://web.facebook.com/profile.php?id=61587026921604", "target", "_blank", "rel", "noopener", 1, "contact-pill", "contact-pill--facebook"], [1, "links"], [2, "margin-top", "12px"], ["id", "toast", "role", "status", "aria-live", "polite", 1, "toast"]], template: function (n, r) { n & 1 && (u(0, "a", 0), f(1, "Skip to content"), d(), u(2, "header")(3, "nav", 1)(4, "a", 2)(5, "span", 3), f(6, "CB"), d(), u(7, "span"), f(8, "Codebase"), d()(), u(9, "button", 4), $(10, "span")(11, "span")(12, "span"), d(), u(13, "div", 5)(14, "a", 6), f(15, "Services"), d(), u(16, "a", 7), f(17, "Projects"), d(), u(18, "a", 8), f(19, "How It Works"), d(), u(20, "a", 9), f(21, "Tech"), d(), u(22, "a", 10), f(23, "FAQ"), d(), u(24, "a", 11), f(25, "Contact"), d(), u(26, "button", 12), $(27, "span", 13), u(28, "span", 14), f(29, "Theme"), d()(), u(30, "a", 15), f(31, "Get Guidance"), d()()()(), u(32, "main", 16)(33, "section", 17)(34, "div", 18)(35, "div")(36, "h1"), f(37, "Bring your idea to the real world"), d(), u(38, "p"), f(39, "Hands-on guidance for Full-Stack, Mobile, IoT, AI/ML, Cybersecurity & DevOps so you build real skills, not copy-paste."), d(), u(40, "div", 19)(41, "a", 15), f(42, "Get Guidance"), d(), u(43, "a", 20), f(44, "View Services"), d()(), u(45, "div", 21)(46, "span"), f(47, "GitHub-first"), d(), u(48, "span"), f(49, "Documentation"), d(), u(50, "span"), f(51, "Viva prep"), d()()(), u(52, "div", 22)(53, "h3", 23), f(54, "Mentored Outcomes"), d(), u(55, "p", 24), f(56, "We guide you to design, implement, and defend your project with confidence."), d(), u(57, "div", 25)(58, "div", 26)(59, "div", 27), ee(), u(60, "svg", 28), $(61, "path", 29), d()(), te(), u(62, "h4"), f(63, "Architecture"), d()(), u(64, "div", 26)(65, "div", 27), ee(), u(66, "svg", 28), $(67, "path", 30)(68, "path", 31), d()(), te(), u(69, "h4"), f(70, "Delivery"), d()(), u(71, "div", 26)(72, "div", 27), ee(), u(73, "svg", 28), $(74, "circle", 32)(75, "path", 33), d()(), te(), u(76, "h4"), f(77, "Timeline"), d()(), u(78, "div", 26)(79, "div", 27), ee(), u(80, "svg", 28), $(81, "path", 34)(82, "path", 35), d()(), te(), u(83, "h4"), f(84, "Viva Prep"), d()()()()()(), u(85, "section", 36)(86, "div", 37)(87, "div", 38)(88, "h2"), f(89, "Services"), d(), u(90, "p"), f(91, "Hands-on mentorship and guidance tailored to your academic rubric and industry expectations."), d()(), u(92, "div", 39)(93, "article", 40)(94, "div", 27), ee(), u(95, "svg", 28), $(96, "rect", 41)(97, "path", 42), d()(), te(), u(98, "h3"), f(99, "Full-Stack Web"), d(), u(100, "ul")(101, "li"), f(102, "REST/GraphQL APIs"), d(), u(103, "li"), f(104, "Auth & dashboards"), d(), u(105, "li"), f(106, "Production-ready deployment"), d()()(), u(107, "article", 43)(108, "div", 27), ee(), u(109, "svg", 28), $(110, "rect", 44)(111, "circle", 45), d()(), te(), u(112, "h3"), f(113, "Mobile Apps"), d(), u(114, "ul")(115, "li"), f(116, "Flutter / native guidance"), d(), u(117, "li"), f(118, "Offline-first design"), d(), u(119, "li"), f(120, "Store-ready release flow"), d()()(), u(121, "article", 46)(122, "div", 27), ee(), u(123, "svg", 28), $(124, "path", 47)(125, "path", 48)(126, "circle", 49), d()(), te(), u(127, "h3"), f(128, "IoT Systems"), d(), u(129, "ul")(130, "li"), f(131, "Sensors + microcontrollers"), d(), u(132, "li"), f(133, "Real-time data pipelines"), d(), u(134, "li"), f(135, "Edge-to-cloud integration"), d()()(), u(136, "article", 50)(137, "div", 27), ee(), u(138, "svg", 28), $(139, "path", 51)(140, "circle", 52), d()(), te(), u(141, "h3"), f(142, "Machine Learning"), d(), u(143, "ul")(144, "li"), f(145, "Data pipelines & features"), d(), u(146, "li"), f(147, "Model training & tuning"), d(), u(148, "li"), f(149, "Evaluation reports"), d()()(), u(150, "article", 53)(151, "div", 27), ee(), u(152, "svg", 28), $(153, "path", 54)(154, "path", 55)(155, "path", 56)(156, "circle", 57)(157, "circle", 58)(158, "circle", 59), d()(), te(), u(159, "h3"), f(160, "Deep Learning"), d(), u(161, "ul")(162, "li"), f(163, "CNN/RNN architectures"), d(), u(164, "li"), f(165, "GPU setup guidance"), d(), u(166, "li"), f(167, "Experiment tracking"), d()()(), u(168, "article", 60)(169, "div", 27), ee(), u(170, "svg", 28), $(171, "path", 61)(172, "path", 62), d()(), te(), u(173, "h3"), f(174, "Cybersecurity"), d(), u(175, "ul")(176, "li"), f(177, "Threat modeling"), d(), u(178, "li"), f(179, "Secure code reviews"), d(), u(180, "li"), f(181, "Defense-focused labs"), d()()(), u(182, "article", 63)(183, "div", 27), ee(), u(184, "svg", 28), $(185, "path", 64)(186, "path", 65), d()(), te(), u(187, "h3"), f(188, "DevOps & Cloud"), d(), u(189, "ul")(190, "li"), f(191, "Docker"), d(), u(192, "li"), f(193, "CI/CD"), d(), u(194, "li"), f(195, "Deployments"), d()()(), u(196, "article", 66)(197, "div", 27), ee(), u(198, "svg", 28), $(199, "rect", 41)(200, "path", 67)(201, "path", 68), d()(), te(), u(202, "h3"), f(203, "UI/UX Design"), d(), u(204, "ul")(205, "li"), f(206, "Wireframes & flows"), d(), u(207, "li"), f(208, "High-fidelity UI"), d(), u(209, "li"), f(210, "Design handoff"), d()()(), u(211, "article", 69)(212, "div", 27), ee(), u(213, "svg", 28), $(214, "path", 70)(215, "path", 71)(216, "path", 72)(217, "path", 73), d()(), te(), u(218, "h3"), f(219, "Report Writing"), d(), u(220, "ul")(221, "li"), f(222, "Structure & format"), d(), u(223, "li"), f(224, "Diagrams & references"), d(), u(225, "li"), f(226, "Final polishing"), d()()(), u(227, "article", 74)(228, "div", 27), ee(), u(229, "svg", 28), $(230, "path", 75)(231, "path", 76)(232, "path", 77)(233, "circle", 78), d()(), te(), u(234, "h3"), f(235, "Project Consulting"), d(), u(236, "ul")(237, "li"), f(238, "Scope & planning"), d(), u(239, "li"), f(240, "Risk review"), d(), u(241, "li"), f(242, "Delivery guidance"), d()()()()()(), u(243, "section", 79)(244, "div", 37)(245, "div", 38)(246, "h2"), f(247, "Projects"), d(), u(248, "p"), f(249, "Sample builds we can guide you through. Pick a direction and we will tailor it to your rubric."), d()(), u(250, "div", 80)(251, "article", 81)(252, "div", 82)(253, "h3"), f(254, "Smart Attendance System"), d(), u(255, "span", 83), f(256, "AI / Web"), d()(), u(257, "p"), f(258, "Face recognition attendance with live dashboard, CSV exports, and admin roles."), d(), u(259, "div", 84)(260, "span"), f(261, "Python"), d(), u(262, "span"), f(263, "OpenCV"), d(), u(264, "span"), f(265, "React"), d()()(), u(266, "article", 81)(267, "div", 82)(268, "h3"), f(269, "IoT Flood Alert Network"), d(), u(270, "span", 83), f(271, "IoT"), d()(), u(272, "p"), f(273, "Sensor nodes stream water-level data with SMS alerts and a realtime map."), d(), u(274, "div", 84)(275, "span"), f(276, "ESP32"), d(), u(277, "span"), f(278, "MQTT"), d(), u(279, "span"), f(280, "Node.js"), d()()(), u(281, "article", 81)(282, "div", 82)(283, "h3"), f(284, "Secure E-Commerce API"), d(), u(285, "span", 83), f(286, "Cybersecurity"), d()(), u(287, "p"), f(288, "Hardened REST API with JWT auth, OWASP checks, and audit logs."), d(), u(289, "div", 84)(290, "span"), f(291, "Spring Boot"), d(), u(292, "span"), f(293, "PostgreSQL"), d(), u(294, "span"), f(295, "Docker"), d()()(), u(296, "article", 81)(297, "div", 82)(298, "h3"), f(299, "Campus Event Mobile App"), d(), u(300, "span", 83), f(301, "Mobile"), d()(), u(302, "p"), f(303, "Event discovery, RSVP, and push notifications with offline mode."), d(), u(304, "div", 84)(305, "span"), f(306, "Flutter"), d(), u(307, "span"), f(308, "Firebase"), d(), u(309, "span"), f(310, "Figma"), d()()(), u(311, "article", 81)(312, "div", 82)(313, "h3"), f(314, "Career Guidance Chatbot"), d(), u(315, "span", 83), f(316, "AI / NLP"), d()(), u(317, "p"), f(318, "Intent-based chatbot with knowledge base and feedback analytics."), d(), u(319, "div", 84)(320, "span"), f(321, "Python"), d(), u(322, "span"), f(323, "Rasa"), d(), u(324, "span"), f(325, "FastAPI"), d()()(), u(326, "article", 81)(327, "div", 82)(328, "h3"), f(329, "Project Tracker Dashboard"), d(), u(330, "span", 83), f(331, "Full-Stack"), d()(), u(332, "p"), f(333, "Kanban workflow, milestones, and weekly progress reporting."), d(), u(334, "div", 84)(335, "span"), f(336, ".NET"), d(), u(337, "span"), f(338, "Angular"), d(), u(339, "span"), f(340, "SQL Server"), d()()()()()(), u(341, "section", 85)(342, "div", 37)(343, "div", 38)(344, "h2"), f(345, "How It Works"), d(), u(346, "p"), f(347, "Structured guidance with a clear timeline, so you can deliver confidently and defend your work."), d()(), u(348, "div", 86)(349, "div", 87)(350, "div", 88), f(351, "1"), d(), u(352, "div")(353, "h3"), f(354, "Requirement Call"), d(), u(355, "p", 89), f(356, "Clarify rubric, domain, and expected outcomes."), d()()(), u(357, "div", 87)(358, "div", 88), f(359, "2"), d(), u(360, "div")(361, "h3"), f(362, "Architecture & Stack"), d(), u(363, "p", 89), f(364, "Select the stack and design the system flow."), d()()(), u(365, "div", 87)(366, "div", 88), f(367, "3"), d(), u(368, "div")(369, "h3"), f(370, "Build With Mentoring"), d(), u(371, "p", 89), f(372, "Hands-on guidance to implement clean, tested modules."), d()()(), u(373, "div", 87)(374, "div", 88), f(375, "4"), d(), u(376, "div")(377, "h3"), f(378, "Docs & Viva Prep"), d(), u(379, "p", 89), f(380, "Documentation, diagrams, and viva rehearsal."), d()()(), u(381, "div", 87)(382, "div", 88), f(383, "5"), d(), u(384, "div")(385, "h3"), f(386, "Final Demo & GitHub Delivery"), d(), u(387, "p", 89), f(388, "Polished demo with complete GitHub repository."), d()()()()()(), u(389, "section", 90)(390, "div", 37)(391, "div", 38)(392, "h2"), f(393, "Tech Stack"), d(), u(394, "p"), f(395, "We align your project with relevant, industry-grade technologies."), d()(), u(396, "div", 91)(397, "div", 92)(398, "span", 93), f(399, "Java"), d(), u(400, "span", 93), f(401, "Spring Boot"), d(), u(402, "span", 93), f(403, ".NET"), d(), u(404, "span", 93), f(405, "React"), d(), u(406, "span", 93), f(407, "Angular"), d(), u(408, "span", 93), f(409, "MySQL"), d(), u(410, "span", 93), f(411, "PostgreSQL"), d(), u(412, "span", 93), f(413, "Docker"), d(), u(414, "span", 93), f(415, "Linux"), d(), u(416, "span", 93), f(417, "GitHub Actions"), d(), u(418, "span", 93), f(419, "Wireshark"), d(), u(420, "span", 93), f(421, "ELK/Wazuh"), d()()()()(), u(422, "section", 94)(423, "div", 37)(424, "div", 38)(425, "h2"), f(426, "FAQ"), d(), u(427, "p"), f(428, "Quick answers to common questions about Codebase mentorship."), d()(), u(429, "div", 95)(430, "div", 96)(431, "button", 97)(432, "strong"), f(433, "No copy-paste policy?"), d(), u(434, "span"), f(435, "+"), d()(), u(436, "div", 98), f(437, "We guide students to build and explain every feature themselves. No copy-paste or ready-made submissions."), d()(), u(438, "div", 96)(439, "button", 97)(440, "strong"), f(441, "How is pricing structured?"), d(), u(442, "span"), f(443, "+"), d()(), u(444, "div", 98), f(445, "Pricing is based on project scope, stack complexity, and mentorship hours. We provide a custom plan after the requirement call."), d()(), u(446, "div", 96)(447, "button", 97)(448, "strong"), f(449, "Typical timelines?"), d(), u(450, "span"), f(451, "+"), d()(), u(452, "div", 98), f(453, "Timelines vary by scope. We define milestones early and keep weekly progress checkpoints."), d()(), u(454, "div", 96)(455, "button", 97)(456, "strong"), f(457, "What will I receive?"), d(), u(458, "span"), f(459, "+"), d()(), u(460, "div", 98), f(461, "You receive a GitHub repository, documentation, diagrams, and guidance for presentations and viva defense."), d()(), u(462, "div", 96)(463, "button", 97)(464, "strong"), f(465, "Cybersecurity ethics?"), d(), u(466, "span"), f(467, "+"), d()(), u(468, "div", 98), f(469, "We focus on defensive, ethical practices. Any security work is aligned with legal and academic standards."), d()(), u(470, "div", 96)(471, "button", 97)(472, "strong"), f(473, "Support after delivery?"), d(), u(474, "span"), f(475, "+"), d()(), u(476, "div", 98), f(477, "We provide a short support window for final fixes and questions so you can submit confidently."), d()()()()(), u(478, "section", 99)(479, "div", 37)(480, "div", 38)(481, "h2"), f(482, "Contact"), d(), u(483, "p"), f(484, "Tell us about your project and we will guide you on the next steps."), d()(), u(485, "div", 100)(486, "div", 101)(487, "form", 102)(488, "div")(489, "label", 103), f(490, "Name"), d(), $(491, "input", 104), d(), u(492, "div")(493, "label", 105), f(494, "Email"), d(), $(495, "input", 106), d(), u(496, "div")(497, "label", 107), f(498, "Phone"), d(), $(499, "input", 108), d(), u(500, "div")(501, "label", 109), f(502, "Project Type"), d(), u(503, "select", 110)(504, "option", 111), f(505, "Select one"), d(), u(506, "option"), f(507, "Full-Stack Web"), d(), u(508, "option"), f(509, "Mobile Apps"), d(), u(510, "option"), f(511, "IoT Systems"), d(), u(512, "option"), f(513, "Machine Learning"), d(), u(514, "option"), f(515, "Deep Learning"), d(), u(516, "option"), f(517, "Cybersecurity"), d(), u(518, "option"), f(519, "DevOps / Cloud"), d()()(), u(520, "div")(521, "label", 112), f(522, "Message"), d(), $(523, "textarea", 113), d(), u(524, "button", 114), f(525, "Send Message"), d()()(), u(526, "div", 115)(527, "h3"), f(528, "Quick Contact"), d(), u(529, "p", 24), f(530, "We respond within 24 hours for new project inquiries."), d(), u(531, "ul", 116)(532, "li")(533, "a", 117), f(534, "WhatsApp: 0723264256"), d()(), u(535, "li")(536, "a", 118), f(537, "Call: 0723264256"), d()(), u(538, "li")(539, "a", 119), f(540, "Email: info.codebaselk@gmail.com"), d()(), u(541, "li")(542, "a", 120), f(543, "Facebook Page"), d()()()()()()()(), u(544, "footer")(545, "div", 37)(546, "strong"), f(547, "Build projects you can defend."), d(), u(548, "div", 121)(549, "a", 6), f(550, "Services"), d(), u(551, "a", 7), f(552, "Projects"), d(), u(553, "a", 8), f(554, "How It Works"), d(), u(555, "a", 9), f(556, "Tech"), d(), u(557, "a", 10), f(558, "FAQ"), d(), u(559, "a", 11), f(560, "Contact"), d()(), u(561, "div", 122), f(562, "\xA9 2026 Codebase. All rights reserved."), d()()(), u(563, "div", 123), f(564, "Message sent! We will contact you shortly."), d()) }, encapsulation: 2 }) }; nc(Mi, Dp).catch(e => console.error(e));
